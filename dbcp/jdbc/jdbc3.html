<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
Sun Microsystems, Inc.<br>
901 San Antonio Road<br>
Palo Alto, CA 94303<br>
U.S.A. 650-960-1300<br>
Send comments about this document to: jdbc@eng.sun.com<br>
JDBC ™ 3.0 Specification<br>
Final Release<br>
Jon Ellis & Linda Ho<br>
with Maydene Fisher<br>
October 2001<br>
Please<br>
Recycle<br>
Java (TM) JDBC (TM) Data Access API Specification ("Specification")<br>
Version:3.0<br>
Status:Final Release<br>
Release:December1, 2001<br>
Copyright 1999-2001 Sun Microsystems, Inc.<br>
901 San Antonio Road, Palo Alto, CA 94303, U.S.A.<br>
All rights reserved.<br>
NOTICE<br>
The Specification is protected by copyright and the information described therein may be protected by one or more U.S. patents, foreign<br>
patents, or pending applications. Except as provided under the following license, no part of the Specification may be reproduced in any<br>
form by any means without the prior written authorization of Sun Microsystems, Inc. ("Sun") and its licensors, if any. Any use of the<br>
Specification and the information described therein will be governed by the terms and conditions of this license and the Export Control<br>
and General Terms as set forth in Sun’s website Legal Terms. By viewing, downloading or otherwise copying the Specification, you<br>
agree that you have read, understood, and will comply with all of the terms and conditions set forth herein.<br>
Subject to the terms and conditions of this license, Sun hereby grants you a fully-paid, non-exclusive, non-transferable, worldwide,<br>
limited license (without the right to sublicense) under Sun’s intellectual property rights to review the Specification internally for the<br>
purposes of evaluation only. Other than this limited license, you acquire no right, title or interest in or to the Specification or any other<br>
Sun intellectual property. The Specification contains the proprietary and confidential information of Sun and may only be used in<br>
accordance with the license terms set forth herein. This license will expire one hundred and eighty (180) days from the date of Release<br>
listed above and will terminate immediately without notice from Sun if you fail to comply with any provision of this license. Upon<br>
termination, you must cease use of or destroy the Specification.<br>
TRADEMARKS<br>
No right, title, or interest in or to any trademarks, service marks, or trade names of Sun or Sun’s licensors is granted hereunder. Sun,<br>
Sun Microsystems, the Sun logo, Java, the Java Coffee Cup Logo, and JDBC are trademarks or registered trademarks of Sun<br>
Microsystems, Inc. in the U.S. and other countries.<br>
DISCLAIMER OF WARRANTIES<br>
THE SPECIFICATION ISPROVIDED "ASIS"AND ISEXPERIMENTAL AND MAYCONTAIN DEFECTSOR DEFICIENCIES<br>
WHICH CANNOT OR WILL NOT BE CORRECTED BYSUN. SUN MAKESNO REPRESENTATIONSOR WARRANTIES,<br>
EITHER EXPRESSOR IMPLIED, INCLUDING BUT NOT LIMITED TO, WARRANTIESOF MERCHANTABILITY, FITNESS<br>
FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT THAT THE CONTENTSOF THE SPECIFICATION ARE<br>
SUITABLE FOR ANYPURPOSE OR THAT ANYPRACTICE OR IMPLEMENTATION OF SUCH CONTENTSWILL NOT<br>
INFRINGE ANYTHIRD PARTYPATENTS, COPYRIGHTS, TRADE SECRETSOR OTHER RIGHTS. This document does not<br>
represent any commitment to release or implement any portion of the Specification in any product.<br>
THE SPECIFICATION COULD INCLUDE TECHNICAL INACCURACIESOR TYPOGRAPHICAL ERRORS. CHANGESARE<br>
PERIODICALLYADDED TO THE INFORMATION THEREIN;THESE CHANGESWILL BE INCORPORATED INTO NEW<br>
VERSIONSOF THE SPECIFICATION, IF ANY. SUN MAYMAKE IMPROVEMENTSAND/ OR CHANGESTO THE<br>
PRODUCT(S) AND/ OR THE PROGRAM(S) DESCRIBED IN THE SPECIFICATION AT ANYTIME. Any use of such changes in<br>
the Specification will be governed by the then-current license for the applicable version of the Specification.<br>
LIMITATION OF LIABILITY<br>
TO THE EXTENT NOT PROHIBITED BYLAW, IN NO EVENT WILL SUN OR ITSLICENSORSBE LIABLE FOR ANY<br>
DAMAGES, INCLUDING WITHOUT LIMITATION, LOST REVENUE, PROFITSOR DATA, OR FOR SPECIAL, INDIRECT,<br>
CONSEQUENTIAL, INCIDENTAL OR PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESSOF THE THEORY<br>
OF LIABILITY, ARISING OUT OF OR RELATED TO ANYFURNISHING, PRACTICING, MODIFYING OR ANYUSE OF THE<br>
SPECIFICATION, EVEN IF SUN AND/ OR ITSLICENSORSHAVE BEEN ADVISED OF THE POSSIBILITYOF SUCH<br>
DAMAGES.<br>
You will indemnify, hold harmless, and defend Sun and its licensors from any claims based on your use of the Specification for any<br>
purposes other than those of internal evaluation, and from any claims that later versions or releases of any Specification furnished to you<br>
are incompatible with the Specification provided to you under this license.<br>
RESTRICTED RIGHTS LEGEND<br>
If this Software is being acquired by or on behalf of the U.S. Government or by a U.S. Government prime contractor or subcontractor (at<br>
any tier), then the Government’s rights in the Software and accompanying<br>
documentation shall be only as set forth in this license;this is in accordance with 48 C.F.R. 227.7201 through 227.7202-4 (for<br>
Department of Defense (DoD) acquisitions) and with 48 C.F.R. 2.101 and 12.212 (for non-DoD acquisitions).<br>
REPORT<br>
You may wish to report any ambiguities, inconsistencies or inaccuracies you may find in connection with your evaluation of the<br>
Specification ("Feedback"). To the extent that you provide Sun with any Feedback, you hereby:(i) agree that such Feedback is<br>
provided on a non-proprietary and non-confidential basis, and (ii) grant Sun a perpetual, non-exclusive, worldwide, fully paid-up,<br>
irrevocable license, with the right to sublicense through multiple levels of sublicensees, to incorporate, disclose, and use without<br>
limitation the Feedback for any purpose related to the Specification and future versions, implementations, and test suites thereof.<br>
(LFI#95308/ Form ID#011801)<br>
Please<br>
Recycle<br>
Contents v<br>
Contents<br>
1. Introduction 13<br>
1.1 The JDBC API 13<br>
1.2 Platforms 13<br>
1.3 Target Audience 14<br>
1.4 Acknowledgements 14<br>
2. Goals 17<br>
3. Summary of New Features 21<br>
3.1 Overview of changes 21<br>
4. Overview 23<br>
4.1 Establishing a Connection 23<br>
4.2 Executing SQL Statements and Manipulating Results 24<br>
4.3 Two-tier Model 25<br>
4.4 Three-tier Model 26<br>
4.5 JDBC in the J2EE Platform 28<br>
5. Classes and Interfaces 29<br>
5.1 The java.sql Package 29<br>
5.2 The javax.sql Package 32<br>
Contents vi<br>
6. Compliance 37<br>
6.1 Definitions 37<br>
6.2 Guidelines and Requirements 38<br>
6.3 JDBC 1.0 API Compliance 39<br>
6.4 JDBC 2.0 API Compliance 39<br>
6.5 JDBC 3.0 API Compliance 40<br>
6.6 Determining Compliance Level 41<br>
6.7 Deprecated APIs 41<br>
7. Database Metadata 43<br>
7.1 Creating a DatabaseMetadata Object 44<br>
7.2 Retrieving General Information 44<br>
7.3 Determining Feature Support 45<br>
7.4 Data Source Limits 45<br>
7.5 SQL Objects and Their Attributes 46<br>
7.6 Transaction Support 46<br>
7.7 New Methods 46<br>
7.8 Modified Methods 47<br>
8. Exceptions 49<br>
8.1 SQLException 49<br>
8.2 SQLWarning 50<br>
8.3 DataTruncation 50<br>
8.4 BatchUpdateException 51<br>
9. Connections 53<br>
9.1 Types of Drivers 54<br>
9.2 The Driver Interface 54<br>
9.3 The DriverManager Class 56<br>
9.4 The DataSource Interface 57<br>
Contents vii<br>
10. Transactions 61<br>
10.1 Transaction Boundaries and Auto-commit 61<br>
10.2 Transaction Isolation Levels 63<br>
10.3 Savepoints 65<br>
11. Connection Pooling 67<br>
11.1 ConnectionPoolDataSource and PooledConnection 69<br>
11.2 Connection Events 70<br>
11.3 Connection Pooling in a Three-tier Environment 71<br>
11.4 DataSource Implementations and Connection Pooling 72<br>
11.5 Deployment 73<br>
11.6 Reuse of Statements by Pooled Connections 75<br>
11.7 ConnectionPoolDataSource Properties 78<br>
12. Distributed Transactions 81<br>
12.1 Infrastructure 81<br>
12.2 XADataSource and XAConnection 84<br>
12.3 XAResource 87<br>
12.4 Transaction Management 88<br>
12.5 Closing the Connection 90<br>
12.6 Limitations of the XAResource Interface 91<br>
13. Statements 93<br>
13.1 The Statement Interface 93<br>
13.2 The PreparedStatement Interface 97<br>
13.3 The CallableStatement Interface 103<br>
13.4 Escape Syntax 109<br>
13.5 Performance Hints 112<br>
13.6 Retrieving Auto Generated Keys 112<br>
14. Result Sets 115<br>
Contents viii<br>
14.1 Kinds of ResultSet Objects 115<br>
14.2 Creating and Manipulating ResultSet Objects 118<br>
15. Batch Updates 127<br>
15.1 Description of Batch Updates 127<br>
16. Advanced Data Types 133<br>
16.1 Taxonomy of SQL Types 133<br>
16.2 Mapping of SQL99 Types 135<br>
16.3 Blob and Clob Objects 135<br>
16.4 Array Objects 137<br>
16.5 Ref Objects 139<br>
16.6 Distinct Types 141<br>
16.7 Structured Types 143<br>
16.8 Datalinks 144<br>
17. Customized Type Mapping 147<br>
17.1 The Type Mapping 147<br>
17.2 Class Conventions 148<br>
17.3 Streams of SQL Data 149<br>
17.4 Examples 151<br>
17.5 Effect of Transform Groups 159<br>
17.6 Generality of the Approach 160<br>
17.7 NULL Data 160<br>
18. Rowsets 163<br>
18.1 Rowsets at Design Time 163<br>
18.2 Rowsets at Run Time 165<br>
19. Relationship to Connectors 167<br>
19.1 System Contracts 167<br>
19.2 Mapping Connector System Contracts to JDBC Interfaces 168<br>
Contents ix<br>
19.3 Packaging JDBC Drivers in Connector RAR File Format 169<br>
A. Revision History 171<br>
B. Data Type Conversion Tables 175<br>
C. Scalar Functions 183<br>
C.1 Numeric Functions 183<br>
C.2 String Functions 184<br>
C.3 Time and Date Functions 185<br>
C.4 System Functions 185<br>
C.5 Conversion Functions 186<br>
D. Related Documents 187<br>
x JDBC 3.0 • October 2001<br>
xi<br>
Preface<br>
This document supersedes and consolidates the content of these predecessor<br>
specifications:<br>
I “JDBC: A Java SQL API”<br>
I “JDBC 2.1 API”<br>
I “JDBC 2.0 Standard Extension API”<br>
New content is summarized in an introductory chapter and then incorporated<br>
throughout this document. The main body of the specification describes the API at a<br>
conceptual level. More extensive details and examples are relegated to the<br>
appendices.<br>
Readers can also download the API specification (Javadoc TM API and comments) for<br>
a complete and precise definition of JDBC classes and interfaces. This documentation<br>
is available from the download page at<br>
http://java.sun.com/products/jdbc/download.html<br>
or it can be browsed at<br>
http://java.sun.com/j2se/1.4/docs/api/java/sql/package-<br>
summary.html<br>
xii JDBC 3.0 • October 2001<br>
Typographic Conventions<br>
Submitting Feedback<br>
Please send any comments and questions concerning this specification to:<br>
jdbc@eng.sun.com<br>
Typeface Meaning Examples<br>
AaBbCc123 The names of commands, files,<br>
and directories; on-screen<br>
computer output<br>
Edit your .login file.<br>
Use ls -a to list all files.<br>
% You have mail.<br>
AaBbCc123 What you type, when<br>
contrasted with on-screen<br>
computer output<br>
% su<br>
Password:<br>
AaBbCc123 Book titles, new words or<br>
terms, words to be emphasized<br>
Command-line variable;<br>
replace with a real name or<br>
value<br>
Read Chapter 6 in the User’s Guide.<br>
These are called class options.<br>
You must be superuser to do this.<br>
To delete a file, type rm filename.<br>
Chapter 1 Introduction 13<br>
CHAPTER 1<br>
Introduction<br>
1.1 The JDBC API<br>
The JDBC TM API provides programmatic access to relational data from the Java TM<br>
programming language. Using the JDBC API, applications written in the Java<br>
programming language can execute SQL statements, retrieve results, and propagate<br>
changes back to an underlying data source. The JDBC API can also be used to<br>
interact with multiple data sources in a distributed, heterogenous environment.<br>
The JDBC API is based on the X/ Open SQL CLI, which is also the basis for ODBC.<br>
JDBC provides a natural and easy-to-use mapping from the Java programming<br>
language to the abstractions and concepts defined in the X/ Open CLI and SQL<br>
standards.<br>
Since its introduction in January 1997, the JDBC API has become widely accepted<br>
and implemented. The flexibility of the API allows for a broad range of<br>
implementations.<br>
1.2 Platforms<br>
The JDBC API is part of the Java platform, which includes the Java TM 2 Standard<br>
Edition (J2SE TM ) and the Java TM 2 Enterprise Edition (J2EE TM ). The JDBC 3.0 API is<br>
divided into two packages: java.sql and javax.sql. Both packages are included<br>
in the J2SE and J2EE platforms.<br>
Chapter 1 Introduction 14<br>
1.3 Target Audience<br>
This specification is targeted primarily towards the vendors of these types of<br>
products:<br>
I drivers that implement the JDBC API<br>
I application servers providing middle-tier services above the driver layer<br>
I tools that use the JDBC API to provide services such as application generation<br>
This specification is also intended to serve the following purposes:<br>
I an introduction for end-users whose applications use the JDBC API<br>
I a starting point for developers of other APIs layered on top of the JDBC API<br>
1.4 Acknowledgements<br>
The authors would like to thank the following members of the expert group for their<br>
invaluable contributions to this document:<br>
I ElhamChandler, Informix<br>
I Stefan Dessloch, IBM<br>
I Christopher Farrar, IBM<br>
I John Goodson, Merant<br>
I Jay Hiremath, Bluestone<br>
I Viquar Hussain, Inprise<br>
I Prabha Krishna, Oracle<br>
I Scott Marlow, Silverstream<br>
I Kuldip Pathak, Informix<br>
I David Schorow, Compaq<br>
I Yeh-Heng Sheng, Informix<br>
I Mark Spotswood, BEA<br>
I Satish Viswanatham, iPlanet<br>
Maydene Fisher has been patient beyond compare in turning what we wrote into<br>
English.<br>
Jennifer Ball has converted scribbles and hand-waving into the diagrams we meant<br>
them to be.<br>
Chapter 1 Introduction 15<br>
The work of Graham Hamilton, Rick Cattell, Mark Hapner, Seth White, and many<br>
others who have worked on JDBC technology in the past has made this specification<br>
possible.<br>
Chapter 1 Introduction 16<br>
Chapter 2 Goals 17<br>
CHAPTER 2<br>
Goals<br>
The JDBC API is a mature technology, having first been specified in January 1997. In<br>
its initial release,the JDBC API focused on providing a basic call-level interface to<br>
SQL databases. The JDBC 2.1 specification and the 2.0 Optional Package<br>
specification then broadened the scope of the API to include support for more<br>
advanced applications and for the features required by application servers to<br>
manage use of the JDBC API on behalf of their applications.<br>
The overall goal of the JDBC 3.0 specification is to “round out” the API by filling in<br>
smaller areas of missing functionality. The following list outlines the goals and<br>
design philosophy for the JDBC API in general and the JDBC 3.0 API in particular:<br>
1. Fit into the J2EE and J2SE platforms<br>
The JDBC API is a constituent technology of the Java platform. The JDBC 3.0 API<br>
should be aligned with the overall direction of the Java 2 Enterprise Edition and<br>
Java 2 Standard Edition platforms.<br>
2. Be consistent with SQL99<br>
The JDBC API provides programmatic access from applications written in the<br>
Java programming language to standard SQL. At the time the JDBC 2.0 API was<br>
in development, the SQL99 specification was a moving target. SQL99 is now a<br>
published standard and includes features that are widely supported among<br>
DBMS vendors as well as features that only a few vendors support. The intent of<br>
the JDBC 3.0 API is to provide access to the subset of SQL99 features that are<br>
likely to be widely supported within the next five years.<br>
3. Consolidate predecessor specifications<br>
This document incorporates content from three prior JDBC specifications to<br>
provide a single standalone specification of the JDBC API.<br>
4. Offer vendor-neutral access to common features<br>
Chapter 2 Goals 18<br>
The JDBC API strives to provide high-bandwidth access to features commonly<br>
supported across different vendor implementations. The goal is to provide a<br>
degree of feature access comparable to what can be achieved by native<br>
applications. However, the API must be general and flexible enough to allow for<br>
a wide range of implementations.<br>
5. Maintain the focus on SQL<br>
The focus of the JDBC API has always been on accessing relational data from the<br>
Java programming language. This continues to be true with the JDBC 3.0 API. The<br>
JDBC 3.0 API does not preclude interacting with other technologies, including<br>
XML, CORBA, or non-relational data, but the primary target will still be relational<br>
data and SQL.<br>
6. Provide a foundation for tools and higher-level APIs<br>
The JDBC API presents a standard API to access a wide range of underlying data<br>
sources or legacy systems. Implementation differences are made transparent<br>
through JDBC API abstractions, making it a valuable target platform for tools<br>
vendors who want to create portable tools and applications.<br>
Because it is a “call-level” interface from the Java programming language to SQL,<br>
the JDBC API is also suitable as a base layer for higher-level facilities such as<br>
Enterprise JavaBeans (EJB) 2.0 container-managed persistence and SQLJ.<br>
7. Keep it simple<br>
The JDBC API is intended to be a simple-to-use, straightforward interface upon<br>
which more complex entities can be built. This goal is achieved by defining many<br>
compact, single-purpose methods instead of a smaller number of complex, multi-<br>
purpose ones with control flag parameters.<br>
8. Enhance reliability, availability, and scalability<br>
Reliability, availability, and scalability are the themes of the J2EE and J2SE<br>
platforms, as well as the direction for future Java platforms. The JDBC 3.0 API<br>
stays true to these themes by enhancing support in several areas, including<br>
resource management, the reuse of prepared statements across logical<br>
connections, and error handling.<br>
9. Maintain backward compatibility with existing applications and drivers<br>
Existing JDBC technology-enabled drivers (“JDBC drivers”) and the applications<br>
that use them must continue to work in an implementation of the Java virtual<br>
machine that supports the JDBC 3.0 API. Applications that use only features<br>
defined in earlier releases of the JDBC API, excluding those that were deprecated<br>
by JDBC 2.0, will not require changes to continue running. It should be<br>
straightforward for existing applications to migrate to JDBC 3.0 technology.<br>
10. Allow forward compatibility with Connectors<br>
Chapter 2 Goals 19<br>
The Connector architecture defines a standard way to package and deploy a<br>
resource adapter that allows a J2EE container to integrate its connection,<br>
transaction, and security management with those of an external resource.<br>
The JDBC 3.0 API provides the migration path for JDBC drivers to the Connector<br>
architecture. It should be possible for vendors whose products use JDBC<br>
technology to move incrementally towards implementing the Connector API. The<br>
expectation is that these implementors will write “resource manager wrappers”<br>
around their existing data source implementations so that they can be reused in a<br>
Connector framework.<br>
11. Specify requirements unambiguously<br>
The requirements for JDBC compliance need to be unambiguous and easy to<br>
identify. The JDBC 3.0 specification and the API documentation (Javadoc<br>
documentation) will clarify which features are required and which are optional.<br>
Chapter 2 Goals 20<br>
Chapter 3 Summary of New Features 21<br>
CHAPTER 3<br>
Summary of New Features<br>
3.1 Overview of changes<br>
The JDBC 3.0 API introduces new material and changes in these areas:<br>
I Savepoint support<br>
Added the Savepoint interface, which contains new methods to set, release, or<br>
roll back a transaction to designated savepoints.<br>
I Reuse of prepared statements by connection pools<br>
Added the ability for deployers to control how prepared statements are pooled<br>
and reused by connections.<br>
I Connection pool configuration<br>
Defined a number of properties for the ConnectionPoolDataSource interface.<br>
These properties can be used to describe how PooledConnection objects<br>
created by DataSource objects should be pooled.<br>
I Retrieval of parameter metadata<br>
Added the interface ParameterMetaData, which describes the number, type<br>
and properties of parameters to prepared statements.<br>
I Retrieval of auto-generated keys<br>
Added a means of retrieving values from columns containing automatically<br>
generated values.<br>
I Ability to have multiple open ResultSet objects<br>
Added the new method getMoreResults(int), whichtakes an argument that<br>
specifies whether ResultSet objects returned by a Statement object should be<br>
closed before returning any subsequent ResultSet objects.<br>
Chapter 3 Summary of New Features 22<br>
I Passing parameters to CallableStatement objects by name<br>
Added methods to allow a string to identify the parameter to be set for a<br>
CallableStatement object.<br>
I Holdable cursor support<br>
Added the ability to specify the of holdability of a ResultSet object.<br>
I BOOLEAN data type<br>
Added the data type java.sql.Types.BOOLEAN. BOOLEAN is logically<br>
equivalent to BIT.<br>
I Making internal updates to the data in Blob and Clob objects<br>
Added methods to allow the data contained in Blob and Clob objects to be<br>
altered.<br>
I Retrieving and updating the object referenced by a Ref object<br>
Added methods to retrieve the object referenced by a Ref object. Also added the<br>
ability to update a referenced object through the Ref object.<br>
I Updating of columns containing BLOB, CLOB, ARRAY and REF types<br>
Added of the updateBlob, updateClob, updateArray, and updateRef<br>
methods to the ResultSet interface.<br>
I DATALINK/ URL data type<br>
Added the data type java.sql.Types.DATALINK, allowing JDBC drivers to<br>
store and retrieve references to external data.<br>
I Transform groups and type mapping<br>
Described the effect of transform groups and how this is reflected in the meta-<br>
data.<br>
I Relationship between the JDBC SPI (Service Provider Interface) and the<br>
Connector architecture<br>
Described the relationship between the JDBC SPI and the connector architecture<br>
in Chapter 19 “Relationship to Connectors”.<br>
I DatabaseMetadata APIs<br>
Added metadata for retrieving SQL type hierarchies. See the JDBC API<br>
Specification for details.<br>
See Chapter 5 “Classes and Interfaces” for a list of the classes and interfaces affected<br>
by these changes.<br>
Chapter 4 Overview 23<br>
CHAPTER 4<br>
Overview<br>
The JDBC API provides a way for Java programs to access one or more sources of<br>
data. In the majority of cases, the data source is a relational DBMS, and its data is<br>
accessed using SQL. However, it is also possible for JDBC technology-enabled<br>
drivers ("JDBC drivers") to be implemented on top of other data sources, including<br>
legacy file systems and object-oriented systems. A primary motivation for the JDBC<br>
API is to provide a standard API for applications to access a wide variety of data<br>
sources.<br>
This chapter introduces some of the key concepts of the JDBC API. In addition, it<br>
describes two common environments for JDBC applications, with a discussion of<br>
how different functional roles are implemented in each one. The two-tier and three-<br>
tier models are logical configurations that can be implemented on a variety of<br>
physical configurations.<br>
4.1 Establishing a Connection<br>
The JDBC API defines the Connection interface to represent a connection to an<br>
underlying data source.<br>
In a typical scenario, a JDBC application will connect to a target data source using<br>
one of two mechanisms:<br>
I DriverManager — this fully implemented class was introduced in the original<br>
JDBC 1.0 API and requires the application to load a specific driver using a hard-<br>
coded URL.<br>
I DataSource — this interface was introduced in the JDBC 2.0 Optional Package<br>
API. It is preferred over DriverManager because it allows details about the<br>
underlying data source to be transparent to the application. A DataSource<br>
object’s properties are set so that it represents a particular data source. When its<br>
getConnection method is invoked, the DataSource instance will return a<br>
connection to that data source. An application can be directed to a different data<br>
Chapter 4 Overview 24<br>
source by simply changing the DataSource object’s properties; no change in<br>
application code is needed. Likewise, a DataSource implementation can be<br>
changed without changing the application code that uses it.<br>
The JDBC API also defines two important extensions of the DataSource interface to<br>
support enterprise applications. These extensions are the following two interfaces:<br>
I ConnectionPoolDataSource — supports caching and reusing of physical<br>
connections, which improves application performance and scalability<br>
I XADataSource — provides connections that can participate in a distributed<br>
transaction<br>
4.2 Executing SQL Statements and<br>
Manipulating Results<br>
Once a connection has been established, an application using the JDBC API can<br>
execute queries and updates against the target data source. The JDBC 3.0 API<br>
provides access to the most commonly implemented features of SQL99. Because<br>
different vendors vary in their level of support for these features, the JDBC API<br>
includes the DatabaseMetadata interface. Applications can use this interface to<br>
determine whether a particular feature is supported by the data source they are<br>
using. The JDBC API also defines escape syntax to allow an application to access<br>
non-standard vendor-specific features. The use of escape syntax has the advantage<br>
of giving JDBC applications access to the same feature set as native applications and<br>
at the same time maintaining the portability of the application.<br>
Applications use methods in the Connection interface to specify transaction<br>
attributes and create Statement, PreparedStatement, or CallableStatement<br>
objects. These statements are used to execute SQL statements and retrieve results.<br>
The ResultSet interface encapsulates the results of an SQL query. Statements may<br>
also be batched, allowing an application to submit multiple updates to a data source<br>
as a single unit of execution.<br>
The JDBC API extends the ResultSet interface with the RowSet interface, thereby<br>
providing a container for tabular data that is much more versatile than a standard<br>
result set. A RowSet object is a JavaBeans TM component, and it may operate without<br>
being connected to its data source. For example, a RowSet implementation can be<br>
serializable and therefore sent across a network, which is particularly useful for<br>
small-footprint clients that want to operate on tabular data without incurring the<br>
overhead of a JDBC driver and data source connection. Another feature of a RowSet<br>
implementation is that it can include a custom reader for accessing any data in<br>
tabular format, not just data in a relational database. Further, a RowSet object can<br>
Chapter 4 Overview 25<br>
update its rows while it is disconnected from its data source, and its implementation<br>
can include a custom writer that writes those updates back to the underlying data<br>
source.<br>
4.2.1 Support for SQL Advanced Data Types<br>
The JDBC API defines standard mappings to convert SQL data types to JDBC data<br>
types and back. This includes support for SQL99 advanced data types such as BLOB,<br>
CLOB, ARRAY, REF, STRUCT, and DISTINCT. JDBC drivers may also implement one or<br>
more customized type mappings for user-defined types (UDTs), in which the UDT is<br>
mapped to a class in the Java programming language. The JDBC 3.0 API also adds<br>
support for externally managed data, for example, data in a file outside the data<br>
source.<br>
4.3 Two-tier Model<br>
A two-tier model divides functionality into a client layer and a server layer, as<br>
shown in FIGURE 4-1 .<br>
FIGURE 4-1 Two-tier Model<br>
The client layer includes the application(s) and one or more JDBC drivers, with the<br>
application handling these areas of responsibility:<br>
Application<br>
data source<br>
JDBC Driver<br>
Chapter 4 Overview 26<br>
I presentation logic<br>
I business logic<br>
I transaction management for multiple-statement transactions or distributed<br>
transactions<br>
I resource management<br>
In this model, the application interacts directly with the JDBC driver(s), including<br>
establishing and managing the physical connection(s) and dealing with the details of<br>
specific underlying data source implementations. The application may use its<br>
knowledge of a specific implementation to take advantage of nonstandard features<br>
or do performance tuning.<br>
Some drawbacks of this model include:<br>
I mingling presentation and business logic with infrastructure and system-level<br>
functions. This presents an obstacle to producing maintainable code with a well-<br>
defined architecture.<br>
I making applications less portable because they are tuned to a particular database<br>
implementation. Applications that require connections to multiple databases must<br>
be aware of the differences between the different vendors’ implementations.<br>
I limiting scalability. Typically, the application will hold onto one or more physical<br>
database connections until it terminates, limiting the number of concurrent<br>
applications that can be supported. In this model, issues of performance,<br>
scalability and availability are handled by the JDBC driver and the corresponding<br>
underlying data source. If an application deals with multiple drivers, it may also<br>
need to be aware of the different ways in which each driver/ data source pair<br>
resolves these issues.<br>
4.4 Three-tier Model<br>
The three-tier model introduces a middle-tier server to house business logic and<br>
infrastructure, as shown in FIGURE 4-2 .<br>
Chapter 4 Overview 27<br>
FIGURE 4-2 Three-tier Model<br>
This architecture is designed to provide improved performance, scalability and<br>
availability for enterprise applications. Functionality is divided among the tiers as<br>
follows:<br>
1. Client tier — a thin layer implementing presentation logic for human interaction.<br>
Java programs, web browsers and PDAs are typical client-tier implementations.<br>
The client interacts with the middle-tier application and does not need to include<br>
any knowledge of infrastructure or underlying data source functions.<br>
2. Middle-tier server — a middle tier that includes:<br>
I Applications to interact with the client and implement business logic. If the<br>
application includes interaction with a data source, it will deal with higher-<br>
level abstractions, such as DataSource objects and logical connections rather<br>
than lower-level driver API.<br>
data source<br>
Web Client<br>
(Browser)<br>
Application<br>
Server<br>
transaction<br>
manager<br>
JDBC<br>
Driver<br>
JDBC<br>
Driver<br>
data source<br>
Middle-tier Server<br>
Application Application<br>
Chapter 4 Overview 28<br>
I An application server to provide supporting infrastructure for a wide range of<br>
applications. This can include management and pooling of physical<br>
connections, transaction management, and the masking of differences between<br>
different JDBC drivers. This last point makes it easier to write portable<br>
applications. The application server role can be implemented by a J2EE server.<br>
Application servers implement the higher-level abstractions used by<br>
applications and interact directly with JDBC drivers.<br>
I JDBC driver(s) to provide connectivity to the underlying data sources. Each<br>
driver implements the standard JDBC API on top of whatever features are<br>
supported by its underlying data source. The driver layer may mask<br>
differences between standard SQL99 syntax and the native dialect supported<br>
by the data source. If the data source is not a relational DBMS, the driver<br>
implements the relational layer used by the application server.<br>
3. Underlying data source — the tier where the data resides. It can include<br>
relational DBMSs, legacy file systems, object-oriented DBMSs, data warehouses,<br>
spreadsheets, or other means of packaging and presenting data. The only<br>
requirement is a corresponding driver that supports the JDBC API.<br>
4.5 JDBC in the J2EE Platform<br>
J2EE components, such as JavaServer TM Pages, Servlets, and Enterprise Java Beans TM<br>
(EJB TM ) components, often require access to relational data and use the JDBC API<br>
for this access. When J2EE components use the JDBC API, the container manages<br>
their transactions and data sources. This means that J2EE component developers do<br>
not directly use the JDBC API’s transaction and datasource management facilities.<br>
See the J2EE Platform Specification for further details.<br>
Chapter 5 Classes and Interfaces 29<br>
CHAPTER 5<br>
Classes and Interfaces<br>
The following classes and interfaces make up the JDBC API.<br>
5.1 The java.sql Package<br>
The core JDBC API is contained in the package java.sql. The classes and interfaces<br>
in java.sql are listed below. Classes are in bold type; interfaces are in standard<br>
type.<br>
java.sql.Array<br>
java.sql.BatchUpdateException<br>
java.sql.Blob<br>
java.sql.CallableStatement<br>
java.sql.Clob<br>
java.sql.Connection<br>
java.sql.DataTruncation<br>
java.sql.DatabaseMetaData<br>
java.sql.Date<br>
java.sql.Driver<br>
java.sql.DriverManager<br>
java.sql.DriverPropertyInfo<br>
java.sql.ParameterMetaData<br>
java.sql.PreparedStatement<br>
java.sql.Ref<br>
java.sql.ResultSet<br>
Chapter 5 Classes and Interfaces 30<br>
java.sql.ResultSetMetaData<br>
java.sql.Savepoint<br>
java.sql.SQLData<br>
java.sql.SQLException<br>
java.sql.SQLInput<br>
java.sql.SQLOutput<br>
java.sql.SQLPermission<br>
java.sql.SQLWarning<br>
java.sql.Statement<br>
java.sql.Struct<br>
java.sql.Time<br>
java.sql.Timestamp<br>
java.sql.Types<br>
The following classes and interfaces are either new or updated in the JDBC 3.0 API.<br>
New classes and interfaces are in bold type.<br>
java.sql.Blob<br>
java.sql.CallableStatement<br>
java.sql.Clob<br>
java.sql.Connection<br>
java.sql.DatabaseMetaData<br>
java.sql.ParameterMetaData<br>
java.sql.PreparedStatement<br>
java.sql.Ref<br>
Java.sql.ResultSet<br>
java.sql.Savepoint<br>
java.sql.SQLInput<br>
java.sql.SQLOutput<br>
java.sql.Statement<br>
java.sql.Types<br>
FIGURE 5-1 shows the interactions and relationships between the key classes and<br>
interfaces in the java.sql package. The methods involved in creating statements,<br>
setting parameters, and retrieving results are also shown.<br>
Chapter 5 Classes and Interfaces 31<br>
FIGURE 5-1 Relationships between major classes and interface in the java.sql package<br>
Connection<br>
Statement<br>
Data types<br>
CallableStatement<br>
ResultSet<br>
PreparedStatement<br>
subclasses<br>
prepareStatement<br>
prepareCall<br>
createStatement<br>
executeQuery<br>
executeQuery<br>
executeQuery<br>
Input to<br>
getXXX<br>
Input/Output of<br>
getMoreResults / getResultSet<br>
subclasses<br>
PreparedStatement<br>
CallableStatement<br>
Chapter 5 Classes and Interfaces 32<br>
5.2 The javax.sql Package<br>
The following list contains the classes and interfaces that are contained in the<br>
javax.sql package. Classes are highlighted in bold; interfaces are in normal type.<br>
javax.sql.ConnectionEvent<br>
javax.sql.ConnectionEventListener<br>
javax.sql.ConnectionPoolDataSource<br>
javax.sql.DataSource<br>
javax.sql.PooledConnection<br>
javax.sql.RowSet<br>
javax.sql.RowSetEvent<br>
javax.sql.RowSetInternal<br>
javax.sql.RowSetListener<br>
javax.sql.RowSetMetaData<br>
javax.sql.RowSetReader<br>
javax.sql.RowSetWriter<br>
javax.sql.XAConnection<br>
javax.sql.XADataSource<br>
Note – The classes and interfaces in the javax.sql package were first made<br>
available as the JDBC 2.0 Optional Package. This optional package was previously<br>
separate from the java.sql package, which was part of J2SE 1.2. Both packages<br>
(java.sql and javax.sql) are now part of J2SE 1.4.<br>
FIGURE 5-2 , FIGURE 5-3 , FIGURE 5-4 , and FIGURE 5-5 show the relationships between key<br>
classes and interfaces in these areas of functionality: DataSource objects,<br>
connection pooling, distributed transactions, and rowsets.<br>
Chapter 5 Classes and Interfaces 33<br>
FIGURE 5-2 Relationship between javax.sql.DataSource and<br>
java.sql.Connection<br>
FIGURE 5-3 Relationships involved in connection pooling<br>
DataSource Connection<br>
java.sql javax.sql<br>
getConnection<br>
Connection PooledConnection<br>
javax.sql java.sql<br>
getConnection<br>
ConnectionPoolDataSource<br>
getConnection<br>
ConnectionEvent<br>
ConnectionEventListener<br>
close or error event<br>
Chapter 5 Classes and Interfaces 34<br>
FIGURE 5-4 Relationships involved in distributed transaction support<br>
XAConnection<br>
PooledConnection<br>
ConnectionEvent<br>
XAResource<br>
ConnectionEventListener<br>
XADataSource<br>
Connection<br>
java.sql javax.sql javax.transaction.xa<br>
getConnection<br>
getXAConnection<br>
getXAResource<br>
subclasses<br>
close or error event<br>
Chapter 5 Classes and Interfaces 35<br>
FIGURE 5-5 RowSet relationships<br>
RowSet<br>
ResultSet<br>
RowSetEvent<br>
RowSetReader<br>
RowSetEventListener<br>
RowSetMetaData RowSetWriter<br>
javax.sql java.sql<br>
subclasses<br>
RowSetInternal<br>
ResultSetMetaData<br>
subclasses<br>
retrieves<br>
metadata<br>
reads data writes data<br>
Chapter 5 Classes and Interfaces 36<br>
Chapter 6 Compliance 37<br>
CHAPTER 6<br>
Compliance<br>
This chapter identifies the features that a JDBC API implementation is required to<br>
support for each level of compliance. A JDBC API implementation includes a JDBC<br>
technology-enabled driver and its underlying data source. Therefore, compliance is<br>
defined in terms of what features are available above the driver layer.<br>
Any features not identified here are optional. In general, a driver is not required to<br>
implement any feature that its underlying data source does not support.<br>
6.1 Definitions<br>
To avoid ambiguity, we will use these terms in our discussion of compliance:<br>
I JDBC API implementation — a JDBC technology-enabled driver and its<br>
underlying data source. The driver may provide support for features that are not<br>
implemented by the underlying data source. It may also provide the mapping<br>
between standard syntax/ semantics and the native API implemented by the data<br>
source.<br>
I Relevant specifications — this document, the API specification, and the relevant<br>
SQL specification. This is also the order of precedence if a feature is described in<br>
more than one of these documents. For the JDBC 1.0 API, the relevant SQL<br>
specification is SQL92 and X/ Open SQL CLI. For the JDBC 2.0 and 3.0 APIs, it is<br>
SQL92 plus the relevant sections of SQL99 and X/ Open SQL CLI.<br>
I Supported feature — a feature for which the JDBC API implementation supports<br>
standard syntax and semantics for that feature as defined in the relevant<br>
specifications.<br>
I Extension — a feature that is not covered by any of the relevant specifications or<br>
a non-standard implementation of a feature that is covered.<br>
I Fully implemented — a term applied to an interface that has all of its methods<br>
implemented to support the semantics defined in the relevant specifications.<br>
Chapter 6 Compliance 38<br>
I Required interface — an interface that must be included although it might not be<br>
fully implemented. Methods that are not implemented should throw an<br>
SQLException to indicate that the corresponding feature is not supported.<br>
6.2 Guidelines and Requirements<br>
The following guidelines apply to all levels of compliance:<br>
I A JDBC API implementation must support Entry Level SQL92 plus the SQL<br>
command Drop Table (see note.)<br>
Entry Level SQL92 represents a "floor" for the level of SQL that a JDBC API<br>
implementation must support. Access to features based on SQL99 should be<br>
provided in a way that is compatible with the relevant part of the SQL99<br>
specification.<br>
I Drivers must support escape syntax. Escape syntax is described in Chapter 13<br>
“Statements”.<br>
I Drivers must support transactions. See Chapter 10 “Transactions” for details.<br>
I Drivers should provide access to every feature implemented by the underlying<br>
data source, including features that extend the JDBC API. When a feature is not<br>
supported, the corresponding methods throw an SQLException. The intent is<br>
for applications using the JDBC API to have access to the same feature set as<br>
native applications.<br>
I If a DatabaseMetaData method indicates that a given feature is supported, it<br>
must be supported via standard syntax and semantics as described in the relevant<br>
specifications. This may require the driver to provide the mapping to the data<br>
source’s native API or SQL dialect if it differs from the standard.<br>
I If a feature is supported, all of the relevant metadata methods must be<br>
implemented. For example, if a JDBC API implementation supports the RowSet<br>
interface, it must also implement the RowSetMetaData interface.<br>
I If a feature is not supported, the corresponding DatabaseMetaData method<br>
must say so. Attempting to access the unsupported feature causes an<br>
SQLException to be thrown.<br>
Note – A JDBC API implementation is required to support the DROP TABLE<br>
command as specified by SQL92, Transitional Level. However, support for the<br>
CASCADE and RESTRICT options of DROP TABLE is optional. In addition, the<br>
behaviour of DROP TABLE is implementation-defined when there are views or<br>
integrity constraints defined that reference the table being dropped.<br>
Chapter 6 Compliance 39<br>
6.3 JDBC 1.0 API Compliance<br>
A driver that is compliant with the JDBC 1.0 API must do the following:<br>
I Adhere to the preceding guidelines and requirements<br>
I Fully implement the following interfaces:<br>
I java.sql.Driver<br>
I java.sql.DatabaseMetaData (excepting those methods introduced in the<br>
JDBC 2.0 API and the JDBC 3.0 API)<br>
I java.sql.ResultSetMetaData (excepting those methods introduced in the<br>
JDBC 2.0 API and the JDBC 3.0 API)<br>
I Include the following required interfaces:<br>
I java.sql.CallableStatement<br>
I java.sql.Connection<br>
I java.sql.PreparedStatement<br>
I java.sql.ResultSet<br>
I java.sql.Statement<br>
6.4 JDBC 2.0 API Compliance<br>
A driver that is compliant with the JDBC 2.0 API must do the following:<br>
I Comply with the JDBC 1.0 API requirements<br>
I Fully implement the DatabaseMetaData interface, including the following<br>
methods added in the JDBC 2.0 API:<br>
I deletesAreDetected<br>
I getConnection<br>
I getUDTs<br>
I insertsAreDetected<br>
I othersDeletesAreVisible<br>
I othersInsertsAreVisible<br>
I othersUpdatesAreVisible<br>
I ownDeletesAreVisible<br>
I ownInsertsAreVisible<br>
Chapter 6 Compliance 40<br>
I ownUpdatesAreVisible<br>
I supportsBatchUpdates<br>
I supportsResultSetConcurrency<br>
I supportsResultSetType<br>
I updatesAreDetected<br>
I Implement the following additional ResultSetMetaData methods:<br>
I getColumnClassName<br>
I getColumnType<br>
I getColumnTypeName<br>
6.5 JDBC 3.0 API Compliance<br>
A driver that is compliant with the JDBC 3.0 API must do the following:<br>
I Comply with the JDBC 2.0 API requirements<br>
I Include the following required interfaces:<br>
I java.sql.ParameterMetaData<br>
I java.sql.Savepoint<br>
I Fully implement the DatabaseMetaData interface, including the following<br>
methods added in the JDBC 3.0 API:<br>
I supportsSavepoints<br>
I supportsNamedParameters<br>
I supportsMultipleOpenResults<br>
I supportsGetGeneratedKeys<br>
I getSuperTypes<br>
I getSuperTables<br>
I getAttributes<br>
I getResultSetHoldability<br>
I supportsResultSetHoldability<br>
I getSQLStateType<br>
I getDatabaseMajorVersion<br>
I getDatabaseMinorVersion<br>
I getJDBCMajorVersion<br>
I getJDBCMinorVersion<br>
Chapter 6 Compliance 41<br>
6.6 Determining Compliance Level<br>
The JDBC API is a constituent technology of the Java platform. Compliance with the<br>
JDBC API specification is determined as a subset of evaluating compliance with the<br>
overall platform.<br>
Note – As of this writing, there is no separate evaluation of compliance level for the<br>
JDBC API.<br>
6.7 Deprecated APIs<br>
Deprecation refers to a class, interface, constructor, method or field that is no longer<br>
recommended and may cease to exist in a future version.<br>
The following constructors and methods were deprecated in the JDBC 2.0 API:<br>
java.sql.CallableStatement.getBigDecimal(int, int)<br>
java.sql.Date(int, int, int)<br>
java.sql.Date.getHours()<br>
java.sql.Date.getMinutes()<br>
java.sql.Date.getSeconds()<br>
java.sql.Date.setHours(int)<br>
java.sql.Date.setMinutes(int)<br>
java.sql.Date.setSeconds(int)<br>
java.sql.DriverManager.getLogStream()<br>
java.sql.DriverManager.setLogStream(PrintStream)<br>
Chapter 6 Compliance 42<br>
java.sql.PreparedStatement.setUnicodeStream(int, InputStream,<br>
int)<br>
java.sql.ResultSet.getBigDecimal(int, int)<br>
java.sql.ResultSet.getBigDecimal(String, int)<br>
java.sql.ResultSet.getUnicodeStream(int)<br>
java.sql.ResultSet.getUnicodeStream(String)<br>
java.sql.Time(int, int, int)<br>
java.sql.Time.getDate()<br>
java.sql.Time.getDay()<br>
java.sql.Time.getMonth()<br>
java.sql.Time.getYear()<br>
java.sql.Time.setDate(int)<br>
java.sql.Time.setMonth(int)<br>
java.sql.Time.setYear(int)<br>
java.sql.Timestamp(int, int, int, int, int, int, int)<br>
Chapter 7 Database Metadata 43<br>
CHAPTER 7<br>
Database Metadata<br>
The DatabaseMetaData interface is implemented by JDBC drivers to provide<br>
information about their underlying data sources. It is used primarily by application<br>
servers and tools to determine how to interact with a given data source.<br>
Applications may also use DatabaseMetaData methods to get information about a<br>
data source, but this is less typical.<br>
The DatabaseMetaData interface includes over 150 methods, which can be<br>
categorized according to the types of information they provide:<br>
I general information about the data source<br>
I whether or not the data source supports a given feature or capability<br>
I data source limits<br>
I what SQL objects the data source contains and attributes of those objects<br>
I transaction support offered by the data source<br>
The DatabaseMetaData interface also contains over 40 fields, which are constants<br>
used as return values for various DatabaseMetaData methods.<br>
This chapter presents an overview of the DatabaseMetaData interface, gives<br>
examples to illustrate the categories of metadata methods, and introduces some new<br>
methods. For a comprehensive listing, however, the reader should consult the JDBC<br>
3.0 API specification.<br>
JDBC also defines the ResultSetMetaData interface, which is discussed in<br>
Chapter 14 “Result Sets”.<br>
Chapter 7 Database Metadata 44<br>
7.1 Creating a DatabaseMetadata Object<br>
A DatabaseMetaData object is created with the Connection method<br>
getMetaData. Once created, it can be used to dynamically discover information<br>
about the underlying data source. CODE EXAMPLE 7-1 creates a DatabaseMetadata<br>
object and uses it to determine the maximum number of characters allowed for a<br>
table name.<br>
// con is a Connection object<br>
DatabaseMetaData dbmd = con.getMetaData();<br>
int maxLen = dbmd.getMaxTableNameLength();<br>
CODE EXAMPLE 7-1 Creating and using a DatabaseMetadata object<br>
7.2 Retrieving General Information<br>
Some DatabaseMetaData methods are used to dynamically discover general<br>
information about a data source as well as some details about its implementation.<br>
Some of the methods in this category are:<br>
I getURL<br>
I getUserName<br>
I getDatabaseProductVersion, getDriverMajorVersion and<br>
getDriverMinorVersion<br>
I getSchemaTerm, getCatalogTerm and getProcedureTerm<br>
I nullsAreSortedHigh and nullsAreSortedLow<br>
I usesLocalFiles and usesLocalFilePerTable<br>
I getSQLKeywords<br>
Chapter 7 Database Metadata 45<br>
7.3 Determining Feature Support<br>
A large group of DatabaseMetaData methods can be used to determine whether a<br>
given feature or set of features is supported by the driver or underlying data source.<br>
Beyond this, some of the methods describe what level of support is provided. Some<br>
of the methods that describe support for individual features are:<br>
I supportsAlterTableWithDropColumn<br>
I supportsBatchUpdates<br>
I supportsTableCorrelationNames<br>
I supportsPositionedDelete<br>
I supportsFullOuterJoins<br>
I supportsStoredProcedures<br>
I supportsMixedCaseQuotedIdentifiers<br>
Methods to describe a level of feature support include:<br>
I supportsANSI92EntryLevelSQL<br>
I supportsCoreSQLGrammar<br>
7.4 Data Source Limits<br>
Another group of methods provides the limits imposed by a given data source.<br>
Some of the methods in this category are:<br>
I getMaxRowSize<br>
I getMaxStatementLength<br>
I getMaxTablesInSelect<br>
I getMaxConnections<br>
I getMaxCharLiteralLength<br>
I getMaxColumnsInTable<br>
Methods in this group return the limit as an int. A return value of zero means that<br>
there is no limit or the limit is unknown.<br>
Chapter 7 Database Metadata 46<br>
7.5 SQL Objects and Their Attributes<br>
Some DatabaseMetaData methods provide information about the SQL objects that<br>
populate a given data source. This group also includes methods to determine the<br>
attributes of those objects. Methods in this group return ResultSet objects in<br>
which each row describes a particular object. For example, the method getUDTs<br>
returns a ResultSet object in which there is a row for each UDT that has been<br>
defined in the data source. Examples of this category are:<br>
I getSchemas and getCatalogs<br>
I getTables<br>
I getPrimaryKeys<br>
I getProcedures and getProcedureColumns<br>
I getUDTs<br>
7.6 Transaction Support<br>
A small group of methods provides information about the transaction semantics<br>
supported by the data source. Examples of this category include:<br>
I supportsMultipleTransactions<br>
I getDefaultTransactionIsolation<br>
7.7 New Methods<br>
The JDBC 3.0 API introduces the following new DatabaseMetaData methods:<br>
I getSuperTypes — returns a description of the user-defined type hierarchies<br>
defined in a given schema in the underlying data source<br>
I getSuperTables — returns a description of the table hierarchies defined in a<br>
given schema in the underlying data source<br>
I getAttributes — returns a description of user-defined type attributes available<br>
from a given catalog in the underlying data source<br>
I getSQLStateType — returns the type of SQLSTATEs that will be returned by<br>
the method SQLException.getSQLState, described in “SQLException” on<br>
page 49.<br>
Chapter 7 Database Metadata 47<br>
I supportsSavepoints — returns true if the JDBC API implementation<br>
supports savepoints, described in “Savepoints” on page 65.<br>
I supportsNamedParameters — returns true if the JDBC API implementation<br>
supports named parameters for CallableStatement objects, described in<br>
“Setting Parameters” on page 98<br>
I supportsMultipleOpenResults — returns true if the JDBC API<br>
implementation supports multiple open result sets for CallableStatement<br>
objects, described in “Returning Unknown or Multiple Results” on page 107<br>
I supportsGetGeneratedKeys — returns true if the JDBC API implementation<br>
supports the retrieval of automatically generated keys, described in “Retrieving<br>
Auto Generated Keys” on page 112<br>
I getResultSetHoldability — returns the default holdability of ResultSet<br>
objects returned by the driver<br>
A complete definition of these methods may be found in the JDBC 3.0 API<br>
specification (Javadoc comments).<br>
7.8 Modified Methods<br>
The JDBC 3.0 API modifies the definitions of these existing DatabaseMetaData<br>
methods, adding support for type hierarchies:<br>
I getTables — returns descriptions of the tables that match the given catalog,<br>
schema, table name, and type criteria<br>
I getColumns — returns descriptions of the columns that match the given catalog,<br>
schema, table name, and column name criteria<br>
I getUDTs — returns descriptions of the user-defined types that match the given<br>
catalog, schema, type name, and type criteria<br>
I getSchemas — now returns the catalog for each schema as well as the schemata.<br>
The JDBC 3.0 API specification includes updated definitions of these methods.<br>
Chapter 7 Database Metadata 48<br>
Chapter 8 Exceptions 49<br>
CHAPTER 8<br>
Exceptions<br>
The SQLException class and its subtypes provide information about errors and<br>
warnings that occur while a data source is being accessed.<br>
8.1 SQLException<br>
An instance of SQLException is thrown when an error occurs during an interaction<br>
with a data source. The exception contains the following information:<br>
I a textual description of the error. The String containing the description can be<br>
retrieved by calling the method SQLException.getMessage.<br>
I a SQLState. The String containing the SQLState can be retrieved by calling the<br>
method SQLException.getSQLState.<br>
The value of the SQLState string will depend on the underlying data source<br>
setting the value. Both X/ Open and SQL99 define SQLState values and the<br>
conditions in which they should be set. Although the sets of values overlap, the<br>
values defined by SQL99 are not a superset of X/ Open.<br>
The DatabaseMetaData method getSQLStateType allows an application to<br>
determine if the SQLStates being returned by a data source are X/ Open or SQL99.<br>
I an error code. This is an integer value identifying the error that caused the<br>
SQLException to be thrown. Its value and meaning are implementation-specific<br>
and may be the actual error code returned by the underlying data source. The<br>
error code can be retrieved using the SQLException.getErrorCode method.<br>
I a reference to any "chained" exceptions. If more than one error occurs or the event<br>
leading up to the exception being thrown can be described as a chain of events,<br>
the exceptions are referenced via this chain. A chained exception can be retrieved<br>
by calling the SQLException.getNextException method on the exception<br>
that was thrown. If no more exceptions are chained, the getNextException<br>
method returns null.<br>
Chapter 8 Exceptions 50<br>
SQLWarning, DataTruncation and BatchUpdateException are the three<br>
subclasses that extend SQLException. These subclasses are described in the<br>
following sections.<br>
8.2 SQLWarning<br>
Methods in the following interfaces will generate an SQLWarning object if they<br>
cause a database access warning:<br>
I Connection<br>
I Statement and its subtypes, PreparedStatement and CallableStatement<br>
I ResultSet<br>
When a method generates an SQLWarning object, the caller is not informed that a<br>
data access warning has occurred. The method getWarnings must be called on the<br>
appropriate object to retrieve the SQLWarning object. However, the<br>
DataTruncation sub-class of SQLWarning may be thrown in some circumstances.<br>
See “DataTruncation” on page 50 for more details.<br>
If multiple data access warnings occur, they are chained to the first one and can be<br>
retrieved by calling the SQLWarning.getNextWarning method. If there are no<br>
more warnings in the chain, getNextWarning returns null.<br>
Subsequent SQLWarning objects continue to be added to the chain until the next<br>
statement is executed or, in the case of a ResultSet object, when the cursor is re-<br>
positioned, at which point all SQLWarning objects in the chain are removed.<br>
8.3 DataTruncation<br>
The DataTruncation class, a subclass of SQLWarning, provides information when<br>
data is truncated. When data truncation occurs on a write to the data source, a<br>
DataTruncation object is thrown. The data value that has been truncated may<br>
have been written to the data source even if a warning has been generated. When<br>
data truncation occurs on a read from the data source, a SQLWarning is reported.<br>
A DataTruncation object contains the following information:<br>
I the descriptive String "Data truncation"<br>
I the SQLState "01004"<br>
Chapter 8 Exceptions 51<br>
I a boolean to indicated whether a column value or a parameter was truncated.<br>
The method DataTruncation.getParameter returns true if a parameter was<br>
truncated and false if a column value was truncated.<br>
I an int giving the index of the column or parameter that was truncated. If the<br>
index of the column or parameter is unknown, the method<br>
DataTruncation.getIndex returns -1. If the index is unknown, the values<br>
returned by the methods DataTruncation.getParameter and<br>
DataTruncation.getRead are undefined.<br>
I a boolean to indicate whether the truncation occurred on a read or a write<br>
operation. The method DataTruncation.getRead returns true if the<br>
truncation occurred on a read and false if the truncation occurred on a write.<br>
I an int indicating the the size of the target field in bytes. The method<br>
DataTruncation.getDataSize returns the number of bytes of data that could<br>
have been transferred or -1 if the number of bytes is unknown.<br>
I an int indicating the actual number of bytes that were transferred. The method<br>
DataTruncation.getTransferSize returns the number of bytes actually<br>
transferred or -1 if the number of bytes is unknown.<br>
8.3.1 Silent Truncation<br>
The Statement.setMaxFieldSize method allows a maximum size (in bytes) to<br>
be set. This limit applies only to the BINARY, VARBINARY, LONGVARBINARY, CHAR,<br>
VARCHAR and LONGVARCHAR data types.<br>
If a limit has been set using setMaxFieldSize and there is an attempt to read or<br>
write data that exceeds the limit, any truncation that occurs as a result of exceeding<br>
the set limit will not be reported.<br>
8.4 BatchUpdateException<br>
A BatchUpdateException object provides information about errors that occur<br>
while a batch of statements is being executed. This exception’s behavior is described<br>
in Chapter 15 “Batch Updates”.<br>
Chapter 8 Exceptions 52<br>
Chapter 9 Connections 53<br>
CHAPTER 9<br>
Connections<br>
A Connection object represents a connection to a data source via a JDBC<br>
technology-enabled driver. The data source can be a DBMS, a legacy file system, or<br>
some other source of data with a corresponding JDBC driver. A single application<br>
using the JDBC API may maintain multiple connections. These connections may<br>
access multiple data sources, or they may all access a single data source.<br>
From the JDBC driver perspective, a Connection object represents a client session.<br>
It has associated state information such as user ID, a set of SQL statements and<br>
result sets being used in that session, and what transaction semantics are in effect.<br>
To obtain a connection, the application may interact with either:<br>
I the DriverManager class working with one or more Driver implementations<br>
OR<br>
I a DataSource implementation<br>
Using a DataSource object is the preferred method because it enhances application<br>
portability, it makes code maintenance easier, and it makes it possible for an<br>
application to transparently make use of connection pooling and distributed<br>
transactions. All J2EE components that establish a connection to a data source use a<br>
DataSource object to get a connection.<br>
This chapter describes the various types of JDBC drivers and the use of the Driver<br>
interface, the DriverManager class, and the basic DataSource interface.<br>
DataSource implementations that support connection pooling and distributed<br>
transactions are discussed in Chapter 11 “Connection Pooling” and Chapter 12<br>
“Distributed Transactions”.<br>
Chapter 9 Connections 54<br>
9.1 Types of Drivers<br>
There are many possible implementations of JDBC drivers. These implementations<br>
are categorized as follows:<br>
I Type 1 — drivers that implement the JDBC API as a mapping to another data<br>
access API, such as ODBC. Drivers of this type are generally dependent on a<br>
native library, which limits their portability. The JDBC-ODBC Bridge driver is an<br>
example of a Type 1 driver.<br>
I Type 2 — drivers that are written partly in the Java programming language and<br>
partly in native code. These drivers use a native client library specific to the data<br>
source to which they connect. Again, because of the native code, their portability<br>
is limited.<br>
I Type 3 — drivers that use a pure Java client and communicate with a middleware<br>
server using a database-independent protocol. The middleware server then<br>
communicates the client’s requests to the data source.<br>
I Type 4 — drivers that are pure Java and implement the network protocol for a<br>
specific data source. The client connects directly to the data source.<br>
9.2 The Driver Interface<br>
JDBC drivers must implement the Driver interface, and the implementation must<br>
contain a static initializer that will be called when the driver is loaded. This<br>
initializer registers a new instance of itself with the DriverManager, as shown in<br>
CODE EXAMPLE 9-1 .<br>
public class AcmeJdbcDriver implements java.sql.Driver {<br>
static {<br>
java.sql.DriverManager.registerDriver(new AcmeJdbcDriver());<br>
}<br>
...<br>
}<br>
CODE EXAMPLE 9-1 Example static initializer for a driver implementing<br>
java.sql.Driver<br>
When an application loads a Driver implementation, which is shown in<br>
CODE EXAMPLE 9-2 , the static initializer will automatically register an instance of the<br>
driver.<br>
Chapter 9 Connections 55<br>
Class.forName("com.acme.jdbc.AcmeJdbcDriver");<br>
CODE EXAMPLE 9-2 Loading a driver that implements java.sql.Driver<br>
To insure that drivers can be loaded using this mechanism, drivers are required to<br>
provide a niladic constructor, that is, a constructor that takes no arguments.<br>
The DriverManager class invokes Driver methods when it wishes to interact with<br>
a registered driver. The Driver interface also includes the method acceptsURL.<br>
The DriverManager can use this method to determine which of its registered<br>
drivers it should use for a given Universal Resource Locator (URL).<br>
When the DriverManager is trying to establish a connection, it calls that driver’s<br>
connect method and passes the driver the URL. If the Driver implementation<br>
understands the URL, it will return a Connection object; otherwise it returns null.<br>
9.2.1 URL Syntax<br>
The recommended JDBC URL syntax is structured as follows:<br>
jdbc:<subprotocol>:<subname><br>
    where a subprotocol names a particular kind of database connectivity mechanism<br>
    that may be supported by one or more drivers. The contents of the subname will<br>
    depend on the subprotocol.<br>
    The recommended syntax for a network address specified as part of a subname<br>
    follows the standard URL naming convention for the subname:<br>
    //hostname:port/subsubname<br>
    The subsubname can have arbitrary internal syntax.<br>
    9.2.2 Registering Subprotocol names<br>
    Sun Microsystems, Java Software Division, will act as an informal registry for JDBC<br>
    subprotocol names. Send mail to jdbc@eng.sun.com to reserve a subprotocol name.<br>
    Chapter 9 Connections 56<br>
    9.3 The DriverManager Class<br>
    The DriverManager class works with the Driver interface to manage the set of<br>
    drivers available to a JDBC client. When the client requests a connection and<br>
    provides a URL, the DriverManager is responsible for finding a driver that<br>
    recognizes the URL and for using it to connect to the corresponding data source.<br>
    Key DriverManager methods include:<br>
    I registerDriver — this method adds a driver to the set of available drivers and<br>
    is invoked implicitly when the driver is loaded. The registerDriver method is<br>
    typically called by the static initializer provided by each driver.<br>
    I getConnection — the method the JDBC client invokes to establish a connection.<br>
    The invocation includes a JDBC URL, which the DriverManager passes to each<br>
    driver in its list until it finds one whose Driver.connect method recognizes the<br>
    URL. That driver returns a Connection object to the DriverManager, which in<br>
    turn passes it to the application.<br>
    CODE EXAMPLE 9-3 illustrates how a JDBC client obtains a connection from the<br>
    DriverManager.<br>
    // Load the driver. This creates an instance of the driver<br>
    // and calls the registerDriver method to make acme.db.Driver<br>
    // available to clients.<br>
    Class.forName("acme.db.Driver");<br>
    // Set up arguments for the call to the getConnection method.<br>
    // The sub-protocol "odbc" in the driver URL indicates the<br>
    // use of the JDBC-ODBC bridge.<br>
    String url = "jdbc:odbc:DSN";<br>
    String user = "SomeUser";<br>
    String passwd = "SomePwd";<br>
    // Get a connection from the first driver in the DriverManager<br>
    // list that recognizes the URL "jdbc:odbc:DSN".<br>
    Connection con = DriverManager.getConnection(url, user, passwd);<br>
    CODE EXAMPLE 9-3 Loading a driver and getting a connection using the DriverManager<br>
    Chapter 9 Connections 57<br>
    The DriverManager class also provides two other getConnection methods:<br>
    I getConnection(String url) for connecting to data sources that do not use a<br>
    username and password.<br>
    I getConnection(String url, java.util.Properties prop), which<br>
    allows the client to connect using a set of properties describing the user name and<br>
    password along with any addition information that may be required.<br>
    The DriverPropertyInfo class provides information on the properties that the<br>
    JDBC driver can understand.<br>
    See the JDBC 3.0 API Specification for more details.<br>
    9.3.1 The SQLPermission Class<br>
    The SQLPermission class represents a set of permissions that a codebase may be<br>
    granted.<br>
    Currently the only permission defined is setLog. The SecurityManager will<br>
    check for the setLog permission when an Applet calls either the DriverManager<br>
    method setLogWriter or setLogStream. If the codebase does not have the<br>
    setLog permission, a java.lang.SecurityException exception will be<br>
    thrown.<br>
    See the JDBC 3.0 API Specification for more details.<br>
    9.4 The DataSource Interface<br>
    The DataSource interface, introduced in JDBC 2.0 Optional Package, is the<br>
    preferred approach to obtaining data source connections. A JDBC driver that<br>
    implements the DataSource interface returns connections that implement the<br>
    same interface, Connection, as those returned by a DriverManager using the<br>
    Driver interface. Using a DataSource object increases application portability by<br>
    making it possible for an application to use a logical name for a data source instead<br>
    of having to supply information specific to a particular driver. A logical name is<br>
    mapped to a DataSource object via a naming service that uses the Java Naming<br>
    and Directory Interface TM (JNDI). The DataSource object represents a physical data<br>
    source and provides connections to that data source. If the data source or<br>
    information about it changes, the properties of the DataSource object can simply be<br>
    modified to reflect the changes; no change in application code is necessary.<br>
    Chapter 9 Connections 58<br>
    The DataSource interface can be implemented so that it transparently provides the<br>
    following:<br>
    I Increased performance and scalability through connection pooling<br>
    I Support for distributed transactions through the XADataSource interface<br>
    The next three sections discuss (1) basic DataSource properties, (2) how logical<br>
    naming using the JNDI API improves an application’s portability and makes it<br>
    easier to maintain, and (3) how to obtain a connection.<br>
    Connection pooling and distributed transactions will be discussed in Chapter 11<br>
    “Connection Pooling” and Chapter 12 “Distributed Transactions”.<br>
    9.4.1 DataSource Properties<br>
    The JDBC API defines a set of properties to identify and describe a DataSource<br>
    implementation. The actual set required for a specific implementation depends on<br>
    the type of DataSource object, that is, whether it is a basic DataSource object, a<br>
    ConnectionPoolDataSource object, or an XADataSource object. The only<br>
    property required for all DataSource implementations is description.<br>
    The following table describes the standard DataSource properties:<br>
    TABLE 9-1 Standard Data Source Properties<br>
    Property Name Type Description<br>
    databaseName String name of a particular database on a server<br>
    dataSourceName String a data source name; used to name an underlying<br>
    XADataSource object or<br>
    ConnectionPoolDataSource object when<br>
    pooling of connections is done<br>
    description String description of this data source<br>
    networkProtocol String network protocol used to communicate with the<br>
    server<br>
    password String a database password<br>
    portNumber int port number where a server is listening for requests<br>
    roleName String the initial SQL rolename<br>
    serverName String database server name<br>
    user String user’s account name<br>
    Chapter 9 Connections 59<br>
    DataSource properties follow the convention specified for properties of<br>
    JavaBeans TM components in the JavaBeans 1.01 Specification. DataSource<br>
    implementations may augment this set with implementation-specific properties. If<br>
    new properties are added, they must be given names that do not conflict with the<br>
    standard property names.<br>
    DataSource implementations must provide “getter” and “setter” methods for each<br>
    property they support. These properties typically are initialized when the<br>
    DataSource object is deployed, as in CODE EXAMPLE 9-4 , in which a<br>
    VendorDataSource object implements the DataSource interface.<br>
    VendorDataSource vds = new VendorDataSource();<br>
    vds.setServerName("my_database_server");<br>
    String name = vds.getServerName();<br>
    CODE EXAMPLE 9-4 Setting and getting a DataSource property<br>
    DataSource properties are not intended to be directly accessible by JDBC clients.<br>
    This design is reinforced by defining the access methods on the implementation class<br>
    rather than on the public DataSource interface used by applications. Furthermore,<br>
    the object that the client manipulates can be a wrapper that only implements the<br>
    DataSource interface. The setter and getter methods for the properties need not be<br>
    exposed to the client.<br>
    Management tools that need to manipulate the properties of a DataSource<br>
    implementation can access those properties using introspection.<br>
    9.4.2 The JNDI API and Application Portability<br>
    The Java Naming and Directory Interface (JNDI) API provides a uniform way for<br>
    applications to access remote services over the network. This section describes how<br>
    it is used to register and access a JDBC DataSource object. See the JNDI<br>
    specification for a complete description of this interface.<br>
    Using the JNDI API, applications can access a DataSource object by specifying its<br>
    logical name. A naming service using the JNDI API maps this logical name to a<br>
    corresponding data source. This scheme greatly enhances portability because any of<br>
    the DataSource properties, such as portNumber or serverName, can be changed<br>
    without impacting the JDBC client code. In fact, the application can be re-directed to<br>
    a different underlying data source in a completely transparent fashion. This is<br>
    particularly useful in the three-tier environment, where an application server hides<br>
    the details of accessing different data sources.<br>
    CODE EXAMPLE 9-5 illustrates the use of a JNDI-based naming service to deploy a<br>
    new VendorDataSource object.<br>
    Chapter 9 Connections 60<br>
    // Create a VendorDataSource object and set some properties<br>
    VendorDataSource vds = new VendorDataSource();<br>
    vds.setServerName("my_database_server");<br>
    vds.setDatabaseName("my_database");<br>
    vds.setDescription("data source for inventory and personnel");<br>
    // Use the JNDI API to register the new VendorDataSource object.<br>
    // Reference the root JNDI naming context and then bind the<br>
    // logical name "jdbc/AcmeDB" to the new VendorDataSource object.<br>
    Context ctx = new InitialContext();<br>
    ctx.bind("jdbc/AcmeDB", vds);<br>
    CODE EXAMPLE 9-5 Registering a DataSource object with a JNDI-based naming service<br>
    Note – J2EE components use a special convention for naming their data sources —<br>
    see Chapter 5 "Naming" in the J2EE platform specification for more details.<br>
    9.4.3 Getting a Connection with a DataSource Object<br>
    Once a DataSource object has been registered with a JNDI-based naming service,<br>
    an application can use it to obtain a connection to the physical data source that it<br>
    represents, as is done in CODE EXAMPLE 9-6 .<br>
    // Get the initial JNDI naming context<br>
    Context ctx = new InitialContext();<br>
    // Get the DataSource object associated with the logical name<br>
    // "jdbc/AcmeDB" and use it to obtain a database connection<br>
    DataSource ds = (DataSource)ctx.lookup("jdbc/AcmeDB");<br>
    Connection con = ds.getConnection("user", "pwd");<br>
    CODE EXAMPLE 9-6 Getting a Connection object using a DataSource object<br>
    The DataSource implementation bound to the name “jdbc/ AcmeDB” can be<br>
    modified or replaced without affecting the application code.<br>
    Chapter 10 Transactions 61<br>
    CHAPTER 10<br>
    Transactions<br>
    Transactions are used to provide data integrity, correct application semantics, and a<br>
    consistent view of data during concurrent access. All JDBC compliant drivers are<br>
    required to provide transaction support. Transaction management in the JDBC API<br>
    mirrors the SQL99 specification and includes these concepts:<br>
    I Auto-commit mode<br>
    I Transaction isolation levels<br>
    I Savepoints<br>
    This chapter describes transaction semantics associated with a single Connection<br>
    object. Transactions involving multiple Connection objects are discussed in<br>
    Chapter 12 “Distributed Transactions”.<br>
    10.1 Transaction Boundaries and Auto-<br>
    commit<br>
    When to start a new transaction is a decision made implicitly by either the JDBC<br>
    driver or the underlying data source. Although some data sources implement an<br>
    explicit “begin transaction” statement, there is no JDBC API to do so. Typically, a<br>
    new transaction is started when the current SQL statement requires one and there is<br>
    no transaction already in place. Whether or not a given SQL statement requires a<br>
    transaction is also specified by SQL99.<br>
    The Connection attribute auto-commit specifies when to end transactions. Enabling<br>
    auto-commit causes the JDBC driver to do a transaction commit after each<br>
    individual SQL statement as soon as it is complete. The point at which a statement<br>
    is considered to be “complete” depends on the type of SQL statement as well as<br>
    what the application does after executing it:<br>
    Chapter 10 Transactions 62<br>
    I For Insert, Update, Delete, and DDL statements, the statement is complete as soon<br>
    as it has finished executing.<br>
    I For Select statements, the statement is complete when the associated result set is<br>
    closed. The result set is closed as soon as one of the following occurs:<br>
    I all of the rows have been retrieved<br>
    I the associated Statement object is re-executed<br>
    I another Statement object is executed on the same connection<br>
    I For CallableStatement objects, the statement is complete when all of the<br>
    associated result sets have been closed.<br>
    10.1.1 Disabling Auto-commit Mode<br>
    CODE EXAMPLE 10-1 shows how to disable auto-commit mode.<br>
    // Assume con is a Connection object<br>
    con.setAutoCommit(false);<br>
    CODE EXAMPLE 10-1 Setting auto-commit off<br>
    When auto-commit is disabled, each transaction must be explicitly commited by<br>
    calling the Connection method commit or else explicitly rolled back by calling the<br>
    Connection method rollback. This is appropriate for cases where transaction<br>
    management is being done in a layer above the driver, such as:<br>
    I when the application needs to group multiple SQL statements into a single<br>
    transaction<br>
    I when the transaction is being managed by the application server<br>
    The default is for auto-commit mode to be enabled when the Connection object is<br>
    created. If the value of auto-commit is changed in the middle of a transaction, the<br>
    current transaction is committed. It is an error to enable auto-commit for a<br>
    connection participating in a distributed transaction, as described in Chapter 12<br>
    “Distributed Transactions”.<br>
    Chapter 10 Transactions 63<br>
    10.2 Transaction Isolation Levels<br>
    Transaction isolation levels specify what data is “visible” to the statements within a<br>
    transaction. They directly impact the level of concurrent access by defining what<br>
    interaction, if any, is possible between transactions against the same target data<br>
    source. Possible interaction between concurrent transactions is categorized as<br>
    follows:<br>
    I dirty reads occur when transactions are allowed to see uncommitted changes to<br>
    the data. In other words, changes made inside a transaction are visible outside the<br>
    transaction before they are commited. If the changes are rolled back instead of<br>
    being committed, it is possible for other transactions to have done work based on<br>
    incorrect, transient data.<br>
    I nonrepeatable reads occur when:<br>
    a. Transaction A reads a row<br>
    b. Transaction B changes the row<br>
    c. Transaction A reads the same row a second time and gets different results<br>
    I phantom reads occur when:<br>
    a. Transaction A reads all rows that satisfy a WHERE condition<br>
    b. Transaction B inserts an additional row that satisfies the same condition<br>
    c. Transaction A reevaluates the WHERE condition and picks up the additional<br>
    “phantom” row<br>
    JDBC augments the four levels of transaction isolation defined by SQL99, by adding<br>
    TRANSACTION_NONE. From least restrictive to most restrictive, the transaction<br>
    isolation levels are:<br>
    1.TRANSACTION_NONE — indicates that the driver does not support transactions,<br>
    which means that it is not a JDBC compliant driver.<br>
    2. TRANSACTION_READ_UNCOMMITTED — allows transactions to see uncommitted<br>
    changes to the data. This means that dirty reads, nonrepeatable reads, and<br>
    phantom reads are possible.<br>
    3. TRANSACTION_READ_COMMITTED — means that any changes made inside a<br>
    transaction are not visible outside the transaction until the transaction is<br>
    committed. This prevents dirty reads, but nonrepeatable reads and phantom<br>
    reads are still possible.<br>
    4. TRANSACTION_REPEATABLE_READ — disallows dirty reads and nonrepeatable<br>
    reads. Phantom read are still possible.<br>
    Chapter 10 Transactions 64<br>
    5. TRANSACTION_SERIALIZABLE — specifies that dirty reads, nonrepeatable reads,<br>
    and phantom reads are prevented.<br>
    10.2.1 Using the setTransactionIsolation Method<br>
    The default transaction level for a Connection object is determined by the driver<br>
    supplying the connection. Typically, it is the default transaction level supported by<br>
    the underlying data source.<br>
    The Connection method setTransactionIsolation is provided to allow<br>
    clients to change the transaction isolation level for a given Connection object. The<br>
    new isolation level remains in effect for the remainder of the session or until the next<br>
    invocation of the setTransactionIsolation method.<br>
    The result of invoking the method setTransactionIsolation in the middle of a<br>
    transaction is implementation-defined.<br>
    The return value of the method getTransactionIsolation should reflect the<br>
    change in isolation level when it actually occurs. It is recommended that drivers<br>
    implement the setTransactionIsolation method to change the isolation level<br>
    starting with the next transaction. Committing the current transaction to make the<br>
    effect immediate is also a valid implementation.<br>
    It is possible for a given JDBC driver to not support all four transaction isolation<br>
    levels (not counting TRANSACTION_NONE). If a driver does not support the isolation<br>
    level specified in an invocation of setTransactionIsolation, it is allowed to<br>
    substitute a higher, more restrictive transaction isolation level. If a driver is unable to<br>
    substitute a higher transaction level, it throws an SQLException. The<br>
    DatabaseMetaData method supportsTransactionIsolationLevel may be<br>
    used to determine whether or not the driver supports a given level.<br>
    10.2.2 Performance Considerations<br>
    As the transaction isolation level increases, more locking and other DBMS overhead<br>
    is required to ensure the correct semantics. This in turn lowers the degree of<br>
    concurrent access that can be supported. As a result, applications may see decreased<br>
    performance when they use a higher transaction isolation level. For this reason, the<br>
    transaction manager, whether it is the application itself or part of the application<br>
    server, should weigh the need for data consistency against the requirements for<br>
    performance when determining which transaction isolation level is appropriate.<br>
    Chapter 10 Transactions 65<br>
    10.3 Savepoints<br>
    Savepoints provide finer-grained control of transactions by marking intermediate<br>
    points within a transaction. Once a savepoint has been set, the transaction can be<br>
    rolled back to that savepoint without affecting preceding work.<br>
    The DatabaseMetaData.supportsSavepoints method can be used to determine<br>
    whether a JDBC API implementation supports savepoints.<br>
    10.3.1 Setting and Rolling Back to a Savepoint<br>
    The JDBC 3.0 API adds the method Connection.setSavepoint, which sets a<br>
    savepoint within the current transaction. The Connection.rollback method has<br>
    been overloaded to take a savepoint argument.<br>
    CODE EXAMPLE 10-2 insertsa row into a table, sets the savepoint svpt1 , and then<br>
    inserts a second row. When the transaction is later rolled back to svpt1 , the second<br>
    insertion is undone, but the first insertion remains intact. In other words, when the<br>
    transaction is committed, only the row containing ’FIRST’ will be added to TAB1.<br>
    Statement stmt = conn.createStatement();<br>
    int rows = stmt.executeUpdate("INSERT INTO TAB1 (COL1) VALUES " +<br>
    "(’FIRST’)");<br>
    // set savepoint<br>
    Savepoint svpt1 = conn.setSavepoint("SAVEPOINT_1");<br>
    rows = stmt.executeUpdate("INSERT INTO TAB1 (COL1) " +<br>
    "VALUES (’SECOND’)");<br>
    ...<br>
    conn.rollback(svpt1);<br>
    ...<br>
    conn.commit();<br>
    CODE EXAMPLE 10-2 Rolling back a transaction to a savepoint<br>
    10.3.2 Releasing a Savepoint<br>
    The method Connection.releaseSavepoint takes a Savepoint object as a<br>
    parameter and removes it from the current transaction.<br>
    Chapter 10 Transactions 66<br>
    Once a savepoint has been released, attempting to reference it in a rollback operation<br>
    will cause an SQLException to be thrown.<br>
    Any savepoints that have been created in a transaction are automatically released<br>
    and become invalid when the transaction is committed or when the entire<br>
    transaction is rolled back.<br>
    Rolling a transaction back to a savepoint automatically releases and makes invalid<br>
    any other savepoints that were created after the savepoint in question.<br>
    Chapter 11 Connection Pooling 67<br>
    CHAPTER 11<br>
    Connection Pooling<br>
    In a basic DataSource implementation, there is a 1:1 correspondence between the<br>
    client’s Connection object and the physical database connection. When the<br>
    Connection object is closed, the physical connection is dropped. Thus, the<br>
    overhead of opening, initializing, and closing the physical connection is incurred for<br>
    each client session.<br>
    A connection pool solves this problem by maintaining a cache of physical database<br>
    connections that can be reused across client sessions. Connection pooling greatly<br>
    improves performance and scalability, particularly in a three-tier environment where<br>
    multiple clients can share a smaller number of physical database connections. In<br>
    FIGURE 11-1 , the JDBC driver provides an implementation of<br>
    ConnectionPoolDataSource that the application server uses to build and<br>
    manage the connection pool.<br>
    The algorithm used to manage the connection pool is implementation-specific and<br>
    varies with application servers. The application server provides its clients with an<br>
    implementation of the DataSource interface that makes connection pooling<br>
    transparent to the client. As a result, the client gets better performance and<br>
    scalability while using the same JNDI and DataSource APIs as before.<br>
    Chapter 11 Connection Pooling 68<br>
    FIGURE 11-1 Connection pooling<br>
    The following sections introduce the ConnectionPoolDataSource interface, the<br>
    PooledConnection interface, and the ConnectionEvent class. These pieces,<br>
    which operate beneath the DataSource and Connection interfaces used by the<br>
    client, are incorporated into a step-by-step description of a typical connection<br>
    pooling implementation. This chapter also describes some important differences<br>
    Application Server<br>
    JDBC<br>
    Application<br>
    Cache of<br>
    PooledConnection objects<br>
    JDBC Driver<br>
    logical<br>
    Connection<br>
    object<br>
    physical<br>
    PooledConnection<br>
    object<br>
    ConnectionPoolDataSource API<br>
    DataSource API<br>
    Chapter 11 Connection Pooling 69<br>
    between a basic DataSource object and one that implements connection pooling. In<br>
    addition, it discusses how a pooled connection can maintain a pool of reusable<br>
    PreparedStatement objects.<br>
    Although much of the discussion in this chapter assumes a three-tier environment,<br>
    connection pooling is also relevant in a two-tier environment. In a two-tier<br>
    environment, the JDBC driver implements both the DataSource and<br>
    ConnectionPoolDataSource interfaces. This implementation allows an<br>
    application that opens and closes multiple connections to benefit from connection<br>
    pooling.<br>
    11.1 ConnectionPoolDataSource and<br>
    PooledConnection<br>
    Typically, a JDBC driver implements the ConnectionPoolDataSource interface,<br>
    and the application server uses it to obtain PooledConnection objects.<br>
    CODE EXAMPLE 11-1 shows the signatures for the two versions of the<br>
    getPooledConnection method.<br>
    public interface ConnectionPoolDataSource {<br>
    PooledConnection getPooledConnection() throws SQLException;<br>
    PooledConnection getPooledConnection(String user,<br>
    String password) throws SQLException;<br>
    ...<br>
    }<br>
    CODE EXAMPLE 11-1 The ConnectionPoolDataSource interface<br>
    A PooledConnection object represents a physical connection to a data source. The<br>
    JDBC driver’s implementation of PooledConnection encapsulates all of the<br>
    details of maintaining that connection.<br>
    An application server caches and reuses PooledConnection objects within its<br>
    implementation of the DataSource interface. When a client calls the method<br>
    DataSource.getConnection, the application server uses the physical<br>
    PooledConnection object to obtain a logical Connection object.<br>
    CODE EXAMPLE 11-2 shows the PooledConnection interface definition.<br>
    Chapter 11 Connection Pooling 70<br>
    public interface PooledConnection {<br>
    Connection getConnection() throws SQLException;<br>
    void close() throws SQLException;<br>
    void addConnectionEventListener(<br>
    ConnectionEventListener listener);<br>
    void removeConnectionEventListener(<br>
    ConnectionEventListener listener);<br>
    }<br>
    CODE EXAMPLE 11-2 The PooledConnection interface<br>
    When an application is finished using a connection, it closes the logical connection<br>
    using the method Connection.close. This closes the logical connection but does<br>
    not close the physical connection. Instead, the physical connection is returned to the<br>
    pool so that it can be reused.<br>
    Connection pooling is completely transparent to the client: A client obtains a pooled<br>
    connection and uses it just the same way it obtains and uses a nonpooled<br>
    connection.<br>
    11.2 Connection Events<br>
    Recall that when an application calls the method Connection.close , the<br>
    underlying physical connection—the PooledConnection object—is available for<br>
    reuse. JavaBeans-style events are used to notify the connection pool manager (the<br>
    application server) that a PooledConnection object can be recycled.<br>
    In order to be notified of an event on a PooledConnection object, the connection<br>
    pool manager must implement the ConnectionEventListener interface and then<br>
    be registered as a listener by that PooledConnection object. The<br>
    ConnectionEventListener interface defines the following two methods, which<br>
    correspond to the two kinds of events that can occur on a PooledConnection<br>
    object:<br>
    I connectionClosed — triggered when the logical Connection object associated<br>
    with this PooledConnection object is closed, that is, the application called the<br>
    method Connection.close<br>
    I connectionErrorOccurred — triggered when a fatal error, such as the server<br>
    crashing, causes the connection to be lost<br>
    Chapter 11 Connection Pooling 71<br>
    A connection pool manager registers itself as a listener for a PooledConnection<br>
    object using the PooledConnection.addConnectionEventListener method.<br>
    Typically, a connection pool manager registers itself as a<br>
    ConnectionEventListener before returning a Connection object to an<br>
    application.<br>
    The driver invokes the ConnectionEventListener methods<br>
    connectionClosed and connectionErrorOccurred when the corresponding<br>
    events occur. Both methods take a ConnectionEvent object as a parameter, which<br>
    can be used to determine which PooledConnection object was closed or had an<br>
    error. When the JDBC application closes its logical connection, the JDBC driver<br>
    notifies the connection pool manager (the listener) by calling the listener’s<br>
    implementation of the method connectionClosed. At this point, the connection<br>
    pool manager can return the PooledConnection object to the pool for reuse.<br>
    When an error occurs, the JDBC driver notifies the listener by calling its<br>
    connectionErrorOccurred method and then throws an SQLException object to<br>
    the application to notify it of the same error. In the event of a fatal error, the bad<br>
    PooledConnection object is not returned to the pool. Instead, the connection pool<br>
    manager calls the PooledConnection.close method on the PooledConnection<br>
    object to close the physical connection.<br>
    11.3 Connection Pooling in a Three-tier<br>
    Environment<br>
    The following sequence of steps outlines what happens when a JDBC client requests<br>
    a connection from a DataSource object that implements connection pooling:<br>
    I The client calls DataSource.getConnection.<br>
    I The application server providing the DataSource implementation looks in its<br>
    connection pool to see if there is a suitable PooledConnection object— a<br>
    physical database connection—available. Determining the suitability of a given<br>
    PooledConnection object may include matching the client’s user authentication<br>
    information or application type as well as using other implementation-specific<br>
    criteria. The lookup method and other methods associated with managing the<br>
    connection pool are specific to the application server.<br>
    I If there are no suitable PooledConnection objects available, the application<br>
    server calls the ConnectionPoolDataSource.getPooledConnection<br>
    method to get a new physical connection. The JDBC driver implementing<br>
    ConnectionPoolDataSource creates a new PooledConnection object and<br>
    returns it to the application server.<br>
    Chapter 11 Connection Pooling 72<br>
    I Regardless of whether the PooledConnection was retrieved from the pool or<br>
    was newly created, the application server does some internal bookkeeping to<br>
    indicate that the physical connection is now in use.<br>
    I The application server calls the method PooledConnection.getConnection<br>
    to get a logical Connection object. This logical Connection object is actually a<br>
    “handle” to a physical PooledConnection object, and it is this handle that is<br>
    returned by the DataSource.getConnection method when connection pooling<br>
    is in effect.<br>
    I The application server registers itself as a ConnectionEventListener by<br>
    calling the method PooledConnection.addConnectionEventListener.<br>
    This is done so that the application server will be notified when the physical<br>
    connection is available for reuse.<br>
    I The logical Connection object is returned to the JDBC client, which uses the<br>
    same Connection API as in the basic DataSource case. Note that the<br>
    underlying physical connection cannot be reused until the client calls the method<br>
    Connection.close.<br>
    Connection pooling can also be implemented in a two-tier environment where there<br>
    is no application server. In this case, the JDBC driver provides both the<br>
    implementation of DataSource which is visible to the client and the underlying<br>
    ConnectionPoolDataSource implementation.<br>
    11.4 DataSource Implementations and<br>
    Connection Pooling<br>
    Aside from improved performance and scalability, a JDBC application should not see<br>
    any difference between accessing a DataSource object that implements connection<br>
    pooling and one that does not. However, there are some important differences in the<br>
    application server and driver level implementations.<br>
    A basic DataSource implementation, that is, one that does not implement<br>
    connection pooling, is typically provided by a JDBC driver vendor. In a basic<br>
    DataSource implementation, the following are true:<br>
    I The DataSource.getConnection method creates a new Connection object<br>
    that represents a physical connection and encapsulates all of the work to set up<br>
    and manage that connection.<br>
    I The Connection.close method shuts down the physical connection and frees<br>
    the associated resources.<br>
    In a DataSource implementation that includes connection pooling, a great deal<br>
    happens behind the scenes. In such an implementation, the following are true:<br>
    Chapter 11 Connection Pooling 73<br>
    I The DataSource implementation includes an implementation-specific<br>
    connection pooling module that manages a cache of PooledConnection objects.<br>
    The DataSource object is typically implemented by the application server as a<br>
    layer on top of the driver’s implementations of the<br>
    ConnectionPoolDataSource and PooledConnection interfaces.<br>
    I The DataSource.getConnection method calls<br>
    PooledConnection.getConnection to get a logical handle to an underlying<br>
    physical connection. The overhead of setting up a new physical connection is<br>
    incurred only if there are no existing connections available in the connection pool.<br>
    When a new physical connection is needed, the connection pool manager will call<br>
    the ConnectionPoolDataSource method getPooledConnection to create<br>
    one. The work to manage the physical connection is delegated to the<br>
    PooledConnection object.<br>
    I The Connection.close method closes the logical handle, but the physical<br>
    connection is maintained. The connection pool manager is notified that the<br>
    underlying PooledConnection object is now available for reuse. If the<br>
    application attempts to reuse the logical handle, the Connection implementation<br>
    throws an SQLException.<br>
    I A single physical PooledConnection object may generate many logical<br>
    Connection objects during its lifetime. For a given PooledConnection object,<br>
    only the most recently produced logical Connection object will be valid. Any<br>
    previously existing Connection object is automatically closed when the associated<br>
    PooledConnection.getConnection method is called. Listeners (connection<br>
    pool managers) are not notified in this case.<br>
    This gives the application server a way to take a connection away from a client.<br>
    This is an unlikely scenario but may be useful if the application server is trying to<br>
    force an orderly shutdown.<br>
    I A connection pool manager shuts down a physical connection by calling the<br>
    method PooledConnection.close. This method is typically called only in<br>
    certain circumstances: when the application server is undergoing an orderly<br>
    shutdown, when the connection cache is being reinitialized, or when the<br>
    application server receives an event indicating that an unrecoverable error has<br>
    occurred on the connection.<br>
    11.5 Deployment<br>
    Deploying a DataSource object that implements connection pooling requires that<br>
    both a client-visible DataSource object and an underlying<br>
    ConnectionPoolDataSource object be registered with a JNDI-based naming<br>
    service.<br>
    Chapter 11 Connection Pooling 74<br>
    The first step is to deploy the ConnectionPoolDataSource implementation, as is<br>
    done in CODE EXAMPLE 11-3 .<br>
    // ConnectionPoolDS implements the ConnectionPoolDataSource<br>
    // interface. Create an instance and set properties.<br>
    com.acme.jdbc.ConnectionPoolDS cpds =<br>
    new com.acme.jdbc.ConnectionPoolDS();<br>
    cpds.setServerName(“bookserver”);<br>
    cpds.setDatabaseName(“booklist”);<br>
    cpds.setPortNumber(9040);<br>
    cpds.setDescription(“Connection pooling for bookserver”);<br>
    // Register the ConnectionPoolDS with JNDI, using the logical name<br>
    // “jdbc/pool/bookserver_pool”<br>
    Context ctx = new InitialContext();<br>
    ctx.bind(“jdbc/pool/bookserver_pool”, cpds);<br>
    CODE EXAMPLE 11-3 Deploying a ConnectionPoolDataSource object<br>
    Once this step is complete, the ConnectionPoolDataSource implementation is<br>
    available as a foundation for the client-visible DataSource implementation. The<br>
    DataSource implementation is deployed such that it references the<br>
    ConnectionPoolDataSource implementation, as shown in CODE EXAMPLE 11-4 .<br>
    // PooledDataSource implements the DataSource interface.<br>
    // Create an instance and set properties.<br>
    com.acme.appserver.PooledDataSource ds =<br>
    new com.acme.appserver.PooledDataSource();<br>
    ds.setDescription(“Datasource with connection pooling”);<br>
    // Reference the previously registered ConnectionPoolDataSource<br>
    ds.setDataSourceName(“jdbc/pool/bookserver_pool”);<br>
    // Register the DataSource implementation with JNDI, using the logical<br>
    // name “jdbc/bookserver”.<br>
    Context ctx = new InitialContext();<br>
    ctx.bind(“jdbc/bookserver”, ds);<br>
    CODE EXAMPLE 11-4 Deploying a DataSource object backed by a<br>
    ConnectionPoolDataSource object<br>
    Chapter 11 Connection Pooling 75<br>
    The DataSource object is now available for use in an application.<br>
    11.6 Reuse of Statements by Pooled<br>
    Connections<br>
    The JDBC 3.0 specification introduces the feature of statement pooling. This feature,<br>
    which allows an application to reuse a PreparedStatement object in much the<br>
    same way it can reuse a connection, is made available through a pooled connection.<br>
    FIGURE 11-2 provides a logical view of how a pool of PreparedStatement objects<br>
    can be associated with a PooledConnection object. As with the<br>
    PooledConnection object itself, the PreparedStatement objects can be reused<br>
    by multiple logical connections in a transparent manner.<br>
    Chapter 11 Connection Pooling 76<br>
    FIGURE 11-2 Logical view of prepared statements reused by pooled connections<br>
    In FIGURE 11-2 , the connection pool and statement pool are implemented by the<br>
    application server. However, this functionality could also be implemented by the<br>
    driver or underlying data source. This discussion of statement pooling is meant to<br>
    allow for any of these implementations.<br>
    11.6.1 Using a Pooled Statement<br>
    If a pooled connection reuses statements, the reuse must be completely transparent<br>
    to an application. In other words, from the application’s point of view, using a<br>
    PreparedStatement object that participates in statement pooling is exactly the<br>
    JDBC<br>
    Application<br>
    JDBC<br>
    Application<br>
    data source<br>
    PooledConnection<br>
    PooledConnection<br>
    Connection Pool<br>
    Application Server<br>
    Pool of<br>
    PreparedStatement<br>
    Objects<br>
    Pool of<br>
    PreparedStatement<br>
    Objects<br>
    Chapter 11 Connection Pooling 77<br>
    same as using one that does not. Statements are kept open for reuse entirely under<br>
    the covers, so there is no change in application code. If an application closes a<br>
    PreparedStatement object, it must still call Connection.prepareStatement<br>
    in order to use it again. The only visible effect of statement pooling is a possible<br>
    improvement in performance.<br>
    An application may find out whether a data source supports statement pooling by<br>
    calling the DatabaseMetaData method supportsStatementPooling. If the<br>
    return value is true, the application can then choose to use PreparedStatement<br>
    objects knowing that they are being pooled.<br>
    In many cases, reusing statements is a significant optimization. This is especially<br>
    true for complex prepared statements. However, it should also be noted that leaving<br>
    large numbers of statements open may have an adverse impact on the use of<br>
    resources.<br>
    11.6.2 Closing a Pooled Statement<br>
    An application closes a pooled statement exactly the same way it closes a nonpooled<br>
    statement. Whether it is pooled or not, a statement that has been closed is no longer<br>
    available for use by the application, and an attempt to reuse it will cause an<br>
    exception to be thrown.<br>
    The following methods can close a pooled statement:<br>
    I Statement.close — called by an application; if the statement is being pooled,<br>
    closes the logical statement used by the application but does not close the<br>
    physical statement being pooled<br>
    I Connection.close — called by an application<br>
    I Nonpooled connection — closes the physical connection and all statements<br>
    created by that connection. This is necessary because the garbage collection<br>
    mechanism is unable to detect when externally managed resources can be<br>
    released.<br>
    I Pooled connection — closes the logical connection and the logical statements it<br>
    returned but leaves open the underlying PooledConnection object and any<br>
    associated pooled statements<br>
    An application cannot directly close a physical statement that is being pooled;<br>
    instead, this is done by the connection pool manager.<br>
    An application also has no direct control over how statements are pooled. A pool of<br>
    statements is associated with a PooledConnection object, whose behaviour is<br>
    determined by the properties of the ConnectionPoolDataSource object that<br>
    produced it. Section 11.7 “ConnectionPoolDataSource Properties” discusses these<br>
    properties.<br>
    Chapter 11 Connection Pooling 78<br>
    11.7 ConnectionPoolDataSource<br>
    Properties<br>
    As with the DataSource interface, the JDBC API defines a set of properties that can<br>
    used to configure the behaviour of connection pools. These are shown in TABLE 11-1 :<br>
    Connection pool configuration properties follow the convention specified for<br>
    JavaBeans components in the JavaBeans specification. Driver vendors may choose to<br>
    augment this set with implementation-specific properties. If so, the additional<br>
    properties must be given names that do not conflict with the standard property<br>
    names.<br>
    Like DataSource implementations, ConnectionPoolDataSource<br>
    implementations must provide “getter” and “setter” methods for each property they<br>
    support. These properties are typically initialized when the<br>
    ConnectionPoolDataSource object is deployed. CODE EXAMPLE 11-5 illustrates<br>
    setting properties in a vendor’s implementation of the<br>
    ConnectionPoolDataSource interface.<br>
    TABLE 11-1 Standard Connection Pool Properties<br>
    Property Name Type Description<br>
    maxStatements int The total number of statements that the pool should<br>
    keep open. 0 (zero) indicates that caching of<br>
    statements is disabled.<br>
    initialPoolSize int The number of physical connections the pool<br>
    should contain when it is created<br>
    minPoolSize int The number of physical connections the pool<br>
    should keep available at all times. 0 (zero) indicates<br>
    that connections should be created as needed.<br>
    maxPoolSize int The maximum number of physical connections that<br>
    the pool should contain. 0 (zero) indicates no<br>
    maximum size.<br>
    maxIdleTime int The number of seconds that a physical connection<br>
    should remain unused in the pool before the<br>
    connection is closed. 0 (zero) indicates no limit.<br>
    propertyCycle int The interval, in seconds, that the pool should wait<br>
    before enforcing the current policy defined by the<br>
    values of the above connection pool properties<br>
    Chapter 11 Connection Pooling 79<br>
    Vendor ConnectionPoolDS vcp = new Vendor ConnectionPool DS();<br>
    vcp.setMaxStatements(25);<br>
    vcp.setInitialPoolSize(10);<br>
    vcp.setMinPoolSize(1);<br>
    vcp.setMaxPoolSize(0);<br>
    vcp.setMaxIdleTime(0);<br>
    vcp.setPropertyCycle(300);<br>
    CODE EXAMPLE 11-5 Setting connection pool configuration properties<br>
    The properties set on a ConnectionPoolDataSource object apply to the<br>
    PooledConnection objects that it creates. An application server managing a pool<br>
    of PooledConnection objects uses these properties to determine how to manage<br>
    its pool.<br>
    ConnectionPoolDataSource configuration properties are not intended to be<br>
    directly accessible by JDBC clients. Management tools that need to manipulate the<br>
    properties of a ConnectionPoolDataSource implementation can access those<br>
    properties using introspection.<br>
    Chapter 11 Connection Pooling 80<br>
    Chapter 12 Distributed Transactions 81<br>
    CHAPTER 12<br>
    Distributed Transactions<br>
    Up to this point, the discussion of transactions has focused on the local case—<br>
    transactions involving a single data source. This chapter introduces the distributed<br>
    case where a single transaction involves multiple connections to one or more<br>
    underlying data sources.<br>
    The following discussion includes these topics:<br>
    I distributed transaction infrastructure<br>
    I transaction managers and resource managers<br>
    I the XADataSource, XAConnection, and XAResource interfaces<br>
    I two-phase commit<br>
    Transaction management in the JDBC API is designed to fit with the Java Transaction<br>
    API TM (JTA TM ) . The examples presented here are high-level; the JTA specification<br>
    should be consulted for a more substantial discussion.<br>
    12.1 Infrastructure<br>
    Distributed transactions require an infrastructure that provides these roles:<br>
    I Transaction manager — controls transaction boundaries and manages the two-<br>
    phase commit protocol. This typically will be an implementation of JTA.<br>
    I JDBC drivers that implement the XADataSource, XAConnection, and<br>
    XAResource interfaces. These are described in the next section.<br>
    I An application-visible implementation of DataSource to “sit on top of” each<br>
    XADataSource object and interact with the transaction manager. The<br>
    DataSource implementation is typically provided by an application server.<br>
    Chapter 12 Distributed Transactions 82<br>
    I Resource manager(s) to manage the underlying data. In the context of the JDBC<br>
    API, a resource manager is a DBMS server. The term “resource manager” is<br>
    borrowed from JTA to emphasize the point that distributed transactions using the<br>
    JDBC API follow the architecture specified in that document.<br>
    This infrastructure is most often implemented in a three-tier architecture that<br>
    includes the following:<br>
    1. A client tier<br>
    2. A middle tier that includes applications, an EJB server working with an external<br>
    transaction manager, and a set of JDBC drivers<br>
    3. Multiple resource managers<br>
    Distributed transactions can also be implemented in two tiers. In a two-tier<br>
    architecture, the application itself acts as the transaction manager and interacts<br>
    directly with the JDBC drivers’ XADataSource implementations.<br>
    The following diagram illustrates the distributed transaction infrastructure:<br>
    Chapter 12 Distributed Transactions 83<br>
    FIGURE 12-1 Infrastructure for distributed transactions<br>
    resource<br>
    manager<br>
    transaction<br>
    manager<br>
    JDBC<br>
    Driver A<br>
    resource<br>
    manager<br>
    Application Server<br>
    Connection<br>
    pool for A<br>
    JDBC Application<br>
    DataSource API<br>
    XAResource<br>
    B 1<br>
    logical<br>
    Connection A 1<br>
    logical<br>
    Connection B 1<br>
    Connection<br>
    pool for B<br>
    JDBC<br>
    Driver B<br>
    XAResource<br>
    A 1<br>
    physical<br>
    XAConnection<br>
    A 1<br>
    XADataSource<br>
    API<br>
    XADataSource<br>
    API<br>
    physical<br>
    XAConnection<br>
    B1<br>
    Chapter 12 Distributed Transactions 84<br>
    The following sections provide more detail on the components of this architecture.<br>
    12.2 XADataSource and XAConnection<br>
    The XADataSource and XAConnection interfaces, which are defined in the<br>
    package javax.sql, are implemented by JDBC drivers that support distributed<br>
    transactions. An XAConnection object is a PooledConnection object that can<br>
    participate in a distributed transaction. More precisely, XAConnection extends the<br>
    PooledConnection interface by adding the method getXAResource. This<br>
    method produces an XAResource object that can be used by a transaction manager<br>
    to coordinate the work done on this connection with the other participants in the<br>
    distributed transaction. CODE EXAMPLE 12-1 gives the definition of the<br>
    XAConnection interface.<br>
    public interface XAConnection extends PooledConnection {<br>
    javax.transaction.xa.XAResource getXAResource()<br>
    throws SQLException;<br>
    }<br>
    CODE EXAMPLE 12-1 The XAConnection interface<br>
    Because they extend the PooledConnection interface, XAConnection objects<br>
    support all the methods of PooledConnection objects. They are reusable physical<br>
    connections to an underlying data source and produce logical connection handles<br>
    that can be passed back to a JDBC application.<br>
    XAConnection objects are produced by an XADataSource object. There is some<br>
    similarity between ConnectionPoolDataSource objects and XADataSource<br>
    objects in that they are both implemented below a DataSource layer that is visible<br>
    to the JDBC application. This architecture allows JDBC drivers to support<br>
    distributed transactions in a way that is transparent to the application.<br>
    CODE EXAMPLE 12-2 shows the signatures for the two getXAConnection methods<br>
    defined in XADataSource.<br>
    public interface XADataSource {<br>
    XAConnection getXAConnection() throws SQLException;<br>
    XAConnection getXAConnection(String user,<br>
    String password) throws SQLException;<br>
    ...<br>
    Chapter 12 Distributed Transactions 85<br>
    }<br>
    CODE EXAMPLE 12-2 The XADataSource interface<br>
    Typically, DataSource implementations built on top of an XADataSource<br>
    implementation will also include a connection pooling module.<br>
    12.2.1 Deploying an XADataSource Object<br>
    Deploying an XADataSource object is done in exactly the same manner as<br>
    previously described for ConnectionPoolDataSource objects. The two-step<br>
    process includes deploying the XADataSource object and the application-visible<br>
    DataSource object, as is done in CODE EXAMPLE 12-3 .<br>
    // com.acme.jdbc.XADataSource implements the<br>
    // XADataSource interface.<br>
    // Create an instance and set properties.<br>
    com.acme.jdbc.XADataSource xads = new com.acme.jdbc.XADataSource();<br>
    xads.setServerName(“bookstore”);<br>
    xads.setDatabaseName(“bookinventory”);<br>
    xads.setPortNumber(9040);<br>
    xads.setDescription(“XADataSource for inventory”);<br>
    // First register xads with a JNDI naming service, using the<br>
    // logical name “jdbc/xa/inventory_xa”<br>
    Context ctx = new InitialContext();<br>
    ctx.bind(“jdbc/xa/inventory_xa”, xads);<br>
    // Next register the overlying DataSource object for application<br>
    // access. com.acme.appserver.DataSource is an implementation of<br>
    // the DataSource interface.<br>
    // Create an instance and set properties.<br>
    com.acme.appserver.DataSource ds =<br>
    new com.acme.appserver.DataSource();<br>
    ds.setDescription(“Datasource supporting distributed transactions”);<br>
    Chapter 12 Distributed Transactions 86<br>
    // Reference the previously registered XADataSource<br>
    ds.setDataSourceName(“jdbc/xa/inventory_xa”);<br>
    // Register the DataSource implementation with a JNDI naming service,<br>
    // using the logical name “jdbc/inventory”.<br>
    ctx.bind(“jdbc/inventory”, ds);<br>
    CODE EXAMPLE 12-3 Deploying a DataSource object backed by an XADataSource object<br>
    12.2.2 Getting a Connection<br>
    As in the connection pooling case, the application call to the method<br>
    DataSource.getConnection returns a logical handle produced by the physical<br>
    XAConnection object. The application code to get a logical connection is shown in<br>
    CODE EXAMPLE 12-4 .<br>
    Context ctx = new InitialContext();<br>
    DataSource ds = (DataSource)ctx.lookup(“jdbc/inventory”);<br>
    Connection con = ds.getConnection(“myID”,“mypasswd”);<br>
    CODE EXAMPLE 12-4 Application code to get a logical connection<br>
    CODE EXAMPLE 12-5 is an example of code from the middle-tier server’s<br>
    implementation of the method DataSource.getConnection.<br>
    // Assume xads is a driver’s implementation of XADataSource<br>
    XADataSource xads = (XADataSource)ctx.lookup(“jdbc/xa/" +<br>
    "inventory_xa”);<br>
    // xacon implements XAConnection<br>
    XAConnection xacon = xads.getXAConnection(“myID”, “mypasswd”);<br>
    // Get a logical connection to pass back up to the application<br>
    Connection con = xacon.getConnection();<br>
    CODE EXAMPLE 12-5 Getting a logical connection from an XAConnection object<br>
    Chapter 12 Distributed Transactions 87<br>
    12.3 XAResource<br>
    The XAResource interface is defined in the JTA specification and is the mapping in<br>
    the Java programming language of the X/ Open Group XA interface. An<br>
    XAResource object is produced by calling the XAConnection.getXAResource<br>
    method and is used to associate an XAConnection object with a distributed<br>
    transaction. A given XAConnection object may be associated with at most one<br>
    transaction at a time. The JDBC driver maintains a one-to-one correspondence<br>
    between an XAResource object and its associated XAConnection object; that is,<br>
    multiple calls to the getXAResource method must all return the same object.<br>
    In a typical scenario, the middle-tier application server calls the method<br>
    XAConnection.getXAResource and passes the returned object to an external<br>
    transaction manager. The transaction manager uses the XAResource object<br>
    exclusively—it does not access an XAConnection object directly.<br>
    The transaction manager coordinates the work of multiple XAResource objects,<br>
    each of which represents a resource manager participating in the distributed<br>
    transaction. Note that two XAResource objects may “point” to the same resource<br>
    manager, that is, they may be associated with XAConnection objects that were<br>
    produced by the same XADataSource object.<br>
    The following XAResource methods are used by the transaction manager to<br>
    implement a two-phase commit protocol. Each method takes an xid parameter that<br>
    identifies the distributed transaction:<br>
    I start — tells the resource manager that the subsequent operations are part of<br>
    the distributed transaction.<br>
    I end — marks the end of this resource manager’s part of the distributed<br>
    transaction.<br>
    I prepare — gets the resource manager’s vote on whether to commit or roll back<br>
    the distributed transaction.<br>
    I commit — tells the resource manager to commit its part of the distributed<br>
    transaction. This method is invoked only if all the participating resource<br>
    managers voted to commit the transaction.<br>
    I rollback — tells the resource manager to roll back its part of the distributed<br>
    transaction. This method is invoked if one or more of the participating resource<br>
    managers voted to roll back the transaction.<br>
    See the JTA specification for a complete description of the XAResouce interface.<br>
    Chapter 12 Distributed Transactions 88<br>
    12.4 Transaction Management<br>
    Participation in a distributed transaction is defined as the work done between<br>
    invocations of the methods XAResource.start and XAResource.end. Outside<br>
    these boundaries, the transaction mode is local, and a connection behaves exactly<br>
    like a local connection.<br>
    With one exception, there is no difference in how an application participating in a<br>
    distributed transaction is coded. In contrast to the local case, the boundaries of a<br>
    distributed transaction must be controlled by an external transaction manager that is<br>
    coordinating the work of multiple connections. For this reason, it is an error for<br>
    applications to call any of the following Connection methods while they are<br>
    participating in a distributed transaction:<br>
    I setAutoCommit(true)<br>
    I commit<br>
    I rollback<br>
    I setSavepoint<br>
    The JDBC driver throws an SQLException if one of these operations is attempted<br>
    on a connection that is participating in a distributed transaction. If the connection is<br>
    later used for a local transaction, these operations are legal at that point.<br>
    Applications should also refrain from calling<br>
    Connection.setTransactionIsolation within the bounds of a distributed<br>
    transaction. The resulting behavior is implementation-defined.<br>
    If a connection has auto-commit mode already enabled at the time it joins a global<br>
    transaction, the attribute will be ignored. The auto-commit behavior will resume<br>
    when the connection returns to local transaction mode.<br>
    12.4.1 Two-phase Commit<br>
    The following steps outline how a transaction manager uses XAResource objects to<br>
    implement the two-phase commit protocol. These steps assume a three-tier<br>
    architecture where an application server is working with an external transaction<br>
    manager:<br>
    1. The application server gets XAResource objects from two different connections:<br>
    // XAConA connects to resource manager A<br>
    javax.transaction.xa.XAResource resourceA = XAConA.getXAResource();<br>
    Chapter 12 Distributed Transactions 89<br>
    // XAConB connects to resource manager B<br>
    javax.transaction.xa.XAResource resourceB = XAConB.getXAResource();<br>
    CODE EXAMPLE 12-6 Getting the XAResource object from an XAConnection object<br>
    2. The application server passes the XAResource objects to the transaction manager.<br>
    The transaction manager does not access the associated XAConnection objects<br>
    directly.<br>
    3. The transaction manager uses the XAResource objects to assign a piece of the<br>
    transaction to each of the associated resource managers. The transaction is<br>
    identified by xid, which represents the identifier generated by the transaction<br>
    manager when the transaction is created.<br>
    // Send work to resource manager A. The TMNOFLAGS argument indicates<br>
    // we are starting a new branch of the transaction, not joining or<br>
    // resuming an existing branch.<br>
    resourceA.start(xid, javax.transaction.xa.TMNOFLAGS);<br>
    // do work with resource manager A<br>
    ...<br>
    // tell resource manager A that it’s done, and no errors have occurred<br>
    resourceA.end(xid, javax.transaction.xa.TMSUCCESS);<br>
    // do work with resource manager B.<br>
    resourceB.start(xid, javax.transaction.xa.TMNOFLAGS);<br>
    // B’s part of the distributed transaction<br>
    ...<br>
    resourceB.end(xid, javax.transaction.xa.TMSUCCESS);<br>
    CODE EXAMPLE 12-7 Starting and ending transaction branches using the XAResource<br>
    interface<br>
    4. The transaction manager initiates the two-phase commit protocol by asking each<br>
    participant to vote:<br>
    resourceA.prepare(xid);<br>
    resourceB.prepare(xid);<br>
    CODE EXAMPLE 12-8 Initiating two-phase commit<br>
    A participating resource manager can vote to roll back the transaction by throwing a<br>
    javax.transaction.xa.XAException.<br>
    Chapter 12 Distributed Transactions 90<br>
    5. If both participants vote to commit, the transaction manager tells each one to<br>
    commit its piece of the distributed transaction (the second parameter tells the<br>
    resource manager not to use a one phase commit protocol on behalf of the xid):<br>
    resourceA.commit(xid, false);<br>
    resourceB.commit(xid, false);<br>
    CODE EXAMPLE 12-9 Committing the distributed transaction<br>
    6. If either resource manager votes to roll back, the transaction manager tells each<br>
    one to roll back its piece of the transaction:<br>
    resourceA.rollback(xid);<br>
    resourceB.rollback(xid);<br>
    CODE EXAMPLE 12-10 Rolling back the distributed transaction<br>
    The transaction manager is not required to use the same XAResource object to<br>
    commit/ rollback a transaction branch as was used to execute the branch. If different<br>
    XAResource objects are used, however, they must be associated with<br>
    XAConnection objects that connect to the same resource manager.<br>
    Note – Steps 1-6 also apply to the case where XAConA and XAConB are two physical<br>
    connections to the same resource manager.<br>
    12.5 Closing the Connection<br>
    In a typical distributed transaction environment, the middle-tier server needs to be<br>
    notified when an application has finished using a connection. As in the earlier<br>
    discussion of PooledConnection objects, the middle-tier server will add itself as a<br>
    ConnectionEventListener so that it will be notified when the application calls<br>
    the method Connection.close. At this point, the server will notify the transaction<br>
    manager so that it can end the transaction branch for the corresponding<br>
    XAResource object. If the server’s DataSource implementation includes<br>
    connection pooling, the connection pooling module will be notified that it can return<br>
    the physical XAConnection object to the pool.<br>
    Note – A distributed transaction may still be active after a participating<br>
    Connection object is closed. This is not true for local transactions.<br>
    Chapter 12 Distributed Transactions 91<br>
    12.6 Limitations of the XAResource Interface<br>
    The javax.transaction.xa.XAResource interface is limited to defining only<br>
    the set of methods needed to join and participate in global transactions, as defined<br>
    by the X/ Open XA standard. This allows any resource manager that implements the<br>
    interface to participate with any other resource manager or transaction manager that<br>
    has the same level of support.<br>
    Functionality that is not defined in the X/ Open standard is correspondingly not<br>
    defined in the XAResource interface. Resource managers that provide for support<br>
    of features not defined in the X/ Open XA standard, such as setting isolation levels,<br>
    cursor holdability, and savepoints in global transactions, will have to do so in an<br>
    implementation-defined way.<br>
    Users who use implementation-defined features should be aware that they will limit<br>
    the portability of their applications.<br>
    Chapter 12 Distributed Transactions 92<br>
    Chapter 13 Statements 93<br>
    CHAPTER 13<br>
    Statements<br>
    This section describes the Statement interface and its subclasses,<br>
    PreparedStatement and CallableStatement. It also describes related topics,<br>
    including escape syntax, performance hints, and auto-generated keys.<br>
    13.1 The Statement Interface<br>
    The Statement interface defines methods for executing SQL statements that do not<br>
    contain parameter markers. The PreparedStatement interface adds methods for<br>
    setting input parameters, and the CallableStatement interface adds methods for<br>
    retrieving output parameter values returned from stored procedures.<br>
    13.1.1 Creating Statements<br>
    Statement objects are created by Connection objects, as is done in<br>
    CODE EXAMPLE 13-1 .<br>
    Connection conn = dataSource.getConnection(user, passwd);<br>
    Statement stmt = conn.createStatement()<br>
    CODE EXAMPLE 13-1 Creating a Statement object<br>
    Each Connection object can create multiple Statement objects that may be used<br>
    concurrently by the program. This is demonstrated in CODE EXAMPLE 13-2 .<br>
    // get a connection from the DataSource object ds<br>
    Connection conn = ds.getConnection(user, passwd);<br>
    // create two instances of Statement<br>
    Chapter 13 Statements 94<br>
    Statement stmt1 = conn.createStatement();<br>
    Statement stmt2 = conn.createStatement();<br>
    CODE EXAMPLE 13-2 Creating multiple Statement objects from a single connection<br>
    13.1.1.1 Setting ResultSet Characteristics<br>
    Additional constructors may be used to set the type and concurrency or the type,<br>
    concurrency, and holdability of any result sets produced by a statement. See<br>
    Chapter 14 “Result Sets” for more on the ResultSet interface.<br>
    CODE EXAMPLE 13-3 creates a Statement object that returns result sets that are<br>
    scrollable, that are insensitive to changes made while the ResultSet object is open,<br>
    that can be updated, and that do not close the ResultSet objects when a commit<br>
    operation is implicity or explicitly performed.<br>
    Connection conn = ds.getConnection(user, passwd);<br>
    Statement stmt = conn.createStatement(<br>
    ResultSet.TYPE_SCROLL_INSENSITIVE,<br>
    ResultSet.CONCUR_UPDATABLE,<br>
    ResultSet.HOLD_CURSOR_OVER_COMMIT);<br>
    CODE EXAMPLE 13-3 Creating a scrollable, insensitive, updatable result set that stays open<br>
    after the method commit is called<br>
    See Chapter 14 “Result Sets” for more information on ResultSet types.<br>
    13.1.2 Executing Statement Objects<br>
    The method used to execute a Statement object depends on the type of SQL<br>
    statement being executed. If the Statement object represents an SQL query<br>
    returning a ResultSet object, the method executeQuery should be used. If the<br>
    SQL is known to be a DDL statement or a DML statement returning an update<br>
    count, the method executeUpdate should be used. If the type of the SQL<br>
    statement is not known, the method execute should be used.<br>
    13.1.2.1 Returning a ResultSet object<br>
    CODE EXAMPLE 13-4 shows the execution of an SQL string returning a ResultSet<br>
    object.<br>
    Chapter 13 Statements 95<br>
    Statement stmt = conn.createStatement();<br>
    ResultSet rs = stmt.executeQuery(“select TITLE, AUTHOR, ISBN " +<br>
    "from BOOKLIST”);<br>
    while (rs.next()){<br>
    ...<br>
    }<br>
    CODE EXAMPLE 13-4 Executing a Statement object that returns a ResultSet object<br>
    If the SQL string being executed does not return a ResultSet object, the method<br>
    executeQuery throws an SQLException.<br>
    13.1.2.2 Returning an Update Count<br>
    In CODE EXAMPLE 13-5 , the SQL statement being executed returns the number of rows<br>
    affected by the update.<br>
    Statement stmt = conn.createStatement();<br>
    int rows = stmt.executeUpdate(“update STOCK set ORDER = ‘Y’ " +<br>
    "where SUPPLY = 0”);<br>
    if (rows > 0) {<br>
    ...<br>
    }<br>
    CODE EXAMPLE 13-5 Executing a Statement object that returns an update count<br>
    The method executeUpdate throws an SQLException if the SQL string being<br>
    executed does not return an update count.<br>
    13.1.2.3 Using the Method execute<br>
    The method execute should be used only when the SQL string being executed<br>
    could return an update count, a ResultSet object, multiple ResultSet objects, or<br>
    the type of the statement is not known. The execute method returns true if the<br>
    first result is a ResultSet object and false if it is an update count. Additional<br>
    methods must be called to retrieve the ResultSet object or update count or to<br>
    retrieve additional results, if any.<br>
    String sql;<br>
    ...<br>
    Chapter 13 Statements 96<br>
    Statement stmt = conn.createStatement();<br>
    boolean b = stmt.execute(sql);<br>
    if (b == true) {<br>
    // b is true if a ResultSet is returned<br>
    ResultSet rs;<br>
    rs = stmt.getResultSet();<br>
    while (rs.next()) {<br>
    ...<br>
    }<br>
    } else {<br>
    // b is false if an update count is returned<br>
    int rows = stmt.getUpdateCount();<br>
    if (rows > 0) {<br>
    ...<br>
    }<br>
    }<br>
    CODE EXAMPLE 13-6 Executing a Statement object that may return an update count or a<br>
    ResultSet object<br>
    When the SQL string being executed returns a ResultSet object, the method<br>
    getUpdateCount returns -1. If the SQL string being executed returns an update<br>
    count, the method getResultSet returns null.<br>
    13.1.3 Closing Statement Objects<br>
    An application calls the method Statement.close to indicate that it has finished<br>
    processing a statement. All Statement objects will be closed when the connection<br>
    that created them is closed. However, it is good coding practice for applications to<br>
    close statements as soon as they have finished processing them. This allows any<br>
    external resources that the statement is using to be released immediately.<br>
    Closing a Statement object will close and invalidate any instances of ResultSet<br>
    produced by that Statement object. The resources held by the ResultSet object<br>
    may not be released until garbage collection runs again, so it is a good practice to<br>
    explicitly close ResultSet objects when they are no longer needed.<br>
    These comments about closing Statement objects apply to PreparedStatement<br>
    and CallableStatement objects as well.<br>
    Chapter 13 Statements 97<br>
    13.2 The PreparedStatement Interface<br>
    The PreparedStatement interface extends Statement, adding the ability to set<br>
    values for parameter markers contained within the statement.<br>
    PreparedStatement objects represent SQL statements that can be prepared, or<br>
    precompiled, for execution once and then executed mulitple times. Parameter<br>
    markers, represented by “?” in the SQL string, are used to specify input vaues to the<br>
    statement that may vary at runtime.<br>
    13.2.1 Creating a PreparedStatement Object<br>
    An instance of PreparedStatement is created in the same manner as a Statement<br>
    object, except that the SQL command is supplied when the statement is created:<br>
    Connection conn = ds.getConnection(user, passwd);<br>
    PreparedStatement ps = conn.prepareStatement(“INSERT INTO BOOKLIST" +<br>
    "(AUTHOR, TITLE, ISBN) VALUES (?, ?, ?)”);<br>
    CODE EXAMPLE 13-7 Creating a PreparedStatement object with three placeholder<br>
    markers<br>
    13.2.1.1 Setting ResultSet Characteristics<br>
    As with createStatement, the method prepareStatement defines a constructor<br>
    that can be used to specify the characteristics of result sets produced by that<br>
    prepared statement.<br>
    Connection conn = ds.getConnection(user, passwd);<br>
    PreparedStatement ps = conn.prepareStatement(<br>
    “SELECT AUTHOR, TITLE FROM BOOKLIST WHERE ISBN = ?”,<br>
    ResultSet.TYPE_FORWARD_ONLY,<br>
    ResultSet.CONCUR_UPDATABLE);<br>
    CODE EXAMPLE 13-8 Creating a PreparedStatement object that returns forward only,<br>
    updatable result sets<br>
    Chapter 13 Statements 98<br>
    13.2.2 Setting Parameters<br>
    The PreparedStatement interface defines setter methods that are used to<br>
    substitute values for each of the parameter markers in the precompiled SQL string.<br>
    The names of the methods follow the pattern "set<Type>".<br>
        For example, the method setString is used to specify a value for a parameter<br>
        marker that expects a string. Each of these setter methods takes at least two<br>
        parameters. The first is always an int equal to the ordinal position of the parameter<br>
        to be set, starting at 1. The second and any remaining parameters specify the value<br>
        to be assigned to the parameter.<br>
        PreparedStatement ps = conn.prepareStatement(“INSERT INTO BOOKLIST" +<br>
        "(AUTHOR, TITLE, ISBN) VALUES (?, ?, ?)”);<br>
        ps.setString(1, “Zamiatin, Evgenii”);<br>
        ps.setString(2, “We”);<br>
        ps.setLong(3, 0140185852);<br>
        CODE EXAMPLE 13-9 Setting parameters in a PreparedStatement object<br>
        A value must be provided for each parameter marker in the PreparedStatement<br>
        object before it can be executed. The methods used to execute a<br>
        PreparedStatement object (executeQuery, executeUpdate and execute) will<br>
        throw an SQLException if a value is not supplied for a parameter marker.<br>
        The values set for the parameter markers of a PreparedStatement object are not<br>
        reset when it is executed. The method clearParameters can be called to explictly<br>
        clear the values that have been set. Setting a parameter with a different value will<br>
        replace the previous value with the new one.<br>
        13.2.2.1 Type Conversions<br>
        The data type specified in a PreparedStatement setter method is a data type in<br>
        the Java programming language. The JDBC driver is responsible for mapping this to<br>
        the corresponding JDBC type (one of the SQL types defined in java.sql.Types) so<br>
        that it is the appropriate type to be sent to the data source. The default mapping is<br>
        specified in Appendix B TABLE B-2.<br>
        13.2.2.2 Type Conversions Using the Method setObject<br>
        The method setObject can be used to convert an object in the Java programming<br>
        language to a JDBC type.<br>
        Chapter 13 Statements 99<br>
        The conversion is explicit when setObject is passed a Java Object and a JDBC<br>
        data type. The driver will attempt to convert the Object to the specified JDBC type<br>
        before passing it to the data source. If the object cannot be converted to the target<br>
        type, an SQLException object is thrown. In CODE EXAMPLE 13-10 , a Java Object of<br>
        type Integer is being converted to the JDBC type SHORT.<br>
        Integer value = new Integer(15);<br>
        ps.setObject(1, value, java.sql.Types.SHORT);<br>
        CODE EXAMPLE 13-10 Converting an Integer object to an SQL SHORT<br>
        If setObject is called without a type parameter, the Java Object is implicitly<br>
        mapped using the default mapping for that object type.<br>
        Integer value = new Integer(15);<br>
        // value is mapped to java.sql.Types.INTEGER<br>
        ps.setObject(1, value);<br>
        CODE EXAMPLE 13-11 The method setObject using the default mapping<br>
        The default mapping is described in Appendix B TABLE B-4<br>
        Note – The method setObject will do custom mapping for SQL UDTs that have a<br>
        custom mapping. See Chapter 17 “Customized Type Mapping” for more<br>
        information.<br>
        13.2.2.3 Setting NULL Parameters<br>
        The method setNull can be used to set any parameter to JDBC NULL. It takes two<br>
        parameters, the ordinal position of the parameter marker, and the JDBC type of the<br>
        parameter.<br>
        ps.setNull(2, java.sql.Types.VARCHAR);<br>
        CODE EXAMPLE 13-12 Setting a String parameter to JDBC NULL<br>
        If a Java null is passed to any of the setter methods that take a Java object, the<br>
        parameter will be set to JDBC NULL.<br>
        Chapter 13 Statements 100<br>
        13.2.3 Describing Outputs and Inputs of a<br>
        PreparedStatement Object<br>
        The method PreparedStatement.getMetaData retrieves a<br>
        ResultSetMetaData object containing a description of the columns that will be<br>
        returned by a prepared statement when is it executed. The ResultSetMetaData<br>
        object contains a record for each column being returned. Methods in the<br>
        ResultSetMetaData interface provide information about the number of columns<br>
        being returned and the characteristics of each column.<br>
        PreparedStatement pstmt = conn.prepareStatement(<br>
        "SELECT * FROM CATALOG");<br>
        ResultSetMetaData rsmd = pstmt.getMetaData();<br>
        int colCount = rsmd.getColumnCount();<br>
        int colType;<br>
        String colLabel;<br>
        for (int i = 1; i <= colCount; i++) {<br>
        colType = rsmd.getColumnType(i);<br>
        colLabel = rsmd.getColumnLabel(i);<br>
        ...<br>
        }<br>
        CODE EXAMPLE 13-13 Creating a ResultSetMetaData object and retrieving column<br>
        information from it<br>
        The method PreparedStatement.getParameterMetaData returns a<br>
        ParameterMetaData object describing the parameter markers that appear in the<br>
        PreparedStatement object. Methods in the ParameterMetaData interface<br>
        provide information about the number of parameters and their characteristics.<br>
        PreparedStatement pstmt = conn.prepareStatement(<br>
        "SELECT * FROM BOOKLIST WHERE ISBN = ?");<br>
        ...<br>
        ParameterMetaData pmd = pstmt.getParameterMetaData();<br>
        int colType = pmd.getParameterType(1);<br>
        ...<br>
        CODE EXAMPLE 13-14 Creating a ParameterMetaData object and retrieving parameter<br>
        information from it<br>
        See the API specification for more details.<br>
        Chapter 13 Statements 101<br>
        13.2.4 Executing a PreparedStatement Object<br>
        As with Statement objects, the method used to execute a PreparedStatement<br>
        object depends on the type of SQL statement being executed. If the<br>
        PreparedStatement object is a query returning a ResultSet object, it should be<br>
        executed with the method executeQuery. If it is a DML statement returning a row<br>
        count, it should be executed with the method executeUpdate. The method<br>
        execute should be used only if the return type of the statement is unknown.<br>
        If any of the PreparedStatement execute methods is called with an SQL string as<br>
        a parameter, an SQLException is thrown.<br>
        13.2.4.1 Returning a ResultSet Object<br>
        CODE EXAMPLE 13-15 shows a query being prepared and then executed multiple<br>
        times.<br>
        PreparedStatement pstmt = conn.prepareStatement(“SELECT AUTHOR, " +<br>
        "TITLE FROM BOOKLIST WHERE SECTION = ?”);<br>
        for (int i = 1; i <= maxSectionNumber; i++) {<br>
        pstmt.setInt(1, i);<br>
        ResultSet rs = pstmt.executeQuery();<br>
        while (rs.next()) {<br>
        // process the record<br>
        }<br>
        rs.close();<br>
        }<br>
        pstmt.close();<br>
        CODE EXAMPLE 13-15 Preparing and executing a statement returning a result set<br>
        If the statement being executed does not return a ResultSet object, the method<br>
        executeQuery throws an SQLException.<br>
        13.2.4.2 Returning a Row Count<br>
        If the statement being prepared and executed is a DML or DDL operation, it should<br>
        be executed using the method executeUpdate. This method returns the number of<br>
        rows that the statement affected.<br>
        Chapter 13 Statements 102<br>
        PreparedStatement pstmt = conn.prepare(<br>
        “update stock set reorder = ’Y’ where stock < ?”);<br>
        pstmt.setInt(1, 5);<br>
        int num = pstmt.executeUpdate();<br>
        CODE EXAMPLE 13-16 Preparing and executing a statement returning an update count<br>
        If the statement being executed returns a ResultSet object, an SQLException is<br>
        thrown.<br>
        13.2.4.3 Using the Method execute<br>
        If the return type of a PreparedStatement object is not known or may return<br>
        multiple ResultSet objects, it should be executed with the execute method. As is<br>
        true with Statement objects, the methods getResultSet and getUpdateCount<br>
        can be used to retrieve a result.<br>
        PreparedStatement pstmt = conn.prepareStatement(sqlStatement);<br>
        // set any parameters the user passes<br>
        ...<br>
        boolean b = pstmt.execute();<br>
        if (b == true) {<br>
        ResultSet rs = pstmt.getResultSet();<br>
        // process a ResultSet<br>
        ...<br>
        }<br>
        } else {<br>
        int rowCount = pstmt.getUpdateCount();<br>
        // process row count<br>
        ...<br>
        }<br>
        }<br>
        CODE EXAMPLE 13-17 Preparing and executing a statement that may return a result set or an<br>
        update count<br>
        Chapter 13 Statements 103<br>
        13.3 The CallableStatement Interface<br>
        The CallableStatement interface extends PreparedStatement with methods<br>
        for executing and retrieving results from storedprocedures.<br>
        13.3.1 Creating a CallableStatement Object<br>
        As with Statement and PreparedStatement objects, CallableStatement<br>
        objects are created by Connection objects. CODE EXAMPLE 13-18 shows the creation<br>
        of a CallableStatement object for calling the stored procedure ‘validate’, which<br>
        has a return parameter and two other parameters.<br>
        CallableStatement cstmt = conn.prepareCall(<br>
        “{? = call validate(?, ?)}”);<br>
        CODE EXAMPLE 13-18 Creating a CallableStatement object<br>
        All the examples in this chapter use the escape syntax for calling stored procedures.<br>
        See “Stored Procedures” on page 111.<br>
        13.3.2 Setting Parameters<br>
        CallableStatement objects may take three types of parameters: IN, OUT, and<br>
        INOUT. The parameter can be specified as either an ordinal parameter or a named<br>
        parameter. A value must be set for each parameter marker in the statement.<br>
        The number, type, and attributes of parameters to a stored procedure can be<br>
        determined using the DatabaseMetaData method getProcedureColumns.<br>
        Parameter ordinals, which are integers passed to the approriate setter method, refer<br>
        to the parameter markers ("?") in the statement, starting at one. Literal parameter<br>
        values in the statement do not increment the ordinal value of the parameter markers.<br>
        In CODE EXAMPLE 13-19 , the two parameter markers have the ordinal values 1 and 2.<br>
        CallableStatement cstmt = con.prepareCall(<br>
        "{CALL PROC(?, "Literal_Value", ?)}");<br>
        cstmt.setString(1, "First");<br>
        cstmt.setString(2, "Third");<br>
        CODE EXAMPLE 13-19 Specifying ordinal parameters<br>
        Chapter 13 Statements 104<br>
        Named parameters can also be used to specify specific parameters. This is especially<br>
        useful when a procedure has many parameters with default values. Named<br>
        parameters can be used to specify only the values that have no default value. The<br>
        name of a parameter corresponds to the COLUMN_NAME field returned by<br>
        DatabaseMetaData.getProcedureColumns.<br>
        In CODE EXAMPLE 13-20 , the procedure COMPLEX_PROC takes ten parameters, but<br>
        only the first and fifth parameters, PARAM_1 and PARAM_5, are required.<br>
        CallableStatement cstmt = con.prepareCall(<br>
        "{CALL COMPLEX_PROC(?, ?)}";<br>
        cstmt.setString("PARAM_1", "Price");<br>
        cstmt.setFloat("PARAM_5", 150.25);<br>
        CODE EXAMPLE 13-20 Specifying two input parameters to a stored procedure<br>
        Additional methods in the CallableStatement interface allow parameters to be<br>
        registered and retrieved by name.<br>
        The DatabaseMetaData.supportsNamedParameters method can be called to<br>
        determine if a JDBC driver and underlying data source support specifying named<br>
        parameters.<br>
        It is not possible to combine setting parameters with ordinals and with names in the<br>
        same statement. If ordinals and names are used for parameters in the same<br>
        statement, an SQLException is thrown.<br>
        Note – In some cases it may not be possible to provide only some of the parameters<br>
        for a procedure. For example, if the procedure name is overloaded, the data source<br>
        determines which procedure to call based on the number of parameters. Enough<br>
        parameters must be provided to allow the data source to resolve any ambiguity.<br>
        13.3.2.1 IN Parameters<br>
        IN parameters are assigned values using the setter methods as described in “Setting<br>
        Parameters” on page 98. In CODE EXAMPLE 13-21 , a string parameter and a date<br>
        parameter are set.<br>
        cstmt.setString(1, “October”);<br>
        cstmt.setDate(2, date);<br>
        CODE EXAMPLE 13-21 Setting IN parameters<br>
        Chapter 13 Statements 105<br>
        13.3.2.2 OUT Parameters<br>
        The method registerOutParameter must be called to set the type for each OUT<br>
        parameter before a CallableStatement object is executed. When the stored<br>
        procedure returns from execution, it will use these types to set the values for any<br>
        OUT parameters.<br>
        The values of OUT parameters can be retrieved using the appropriate getter<br>
        methods defined in the CallableStatement interface. CODE EXAMPLE 13-22 shows<br>
        the execution of a stored procedure with two OUT parameters, a string and float,<br>
        and the retrieval of the OUT parameter values.<br>
        CallableStatement cstmt = conn.prepareCall(<br>
        “{CALL GET_NAME_AND_NUMBER(?, ?)}");<br>
        cstmt.registerOutParameter(1, java.sql.Types.STRING);<br>
        cstmt.registerOutParameter(2, java.sql.Types.FLOAT);<br>
        cstmt.execute();<br>
        // Retrieve OUT parameters<br>
        String name = cstmt.getString(1);<br>
        float number = cstmt.getFloat(2);<br>
        CODE EXAMPLE 13-22 Registering and retrieving OUT parameters<br>
        13.3.2.3 INOUT Parameters<br>
        Parameters that are both input and output parameters must be both set by using the<br>
        appropriate setter method and also registered by calling the<br>
        registerOutParameter method. The type implied by the setter method (see<br>
        TABLE B-1 in Appendix B “Data Type Conversion Tables‘‘) and the type supplied to<br>
        the method registerOutParameter must be the same.<br>
        CODE EXAMPLE 13-23 shows the stored procedure calc, which takes one INOUT float<br>
        parameter.<br>
        CallableStatement cstmt = conn.prepareCall(“{CALL CALC(?)}”);<br>
        cstmt.setFloat(1, 1237.98f);<br>
        ctsmt.registerOutParameter(1, java.sql.Types.FLOAT);<br>
        cstmt.execute();<br>
        float f = cstmt.getFloat(1);<br>
        CODE EXAMPLE 13-23 Executing a CallableStatement object with an INOUT parameter<br>
        Chapter 13 Statements 106<br>
        13.3.3 Executing a CallableStatement Object<br>
        As with Statement and PreparedStatement objects, the method used to execute<br>
        a CallableStatement object depends on whether it returns a single ResultSet<br>
        object, an update count, or multiple mixed results.<br>
        13.3.3.1 Returning a Single ResultSet Object<br>
        CODE EXAMPLE 13-24 shows the execution of a CallableStatement object that takes<br>
        one input parameter and returns a single ResultSet object.<br>
        CallableStatement cstmt = conn.prepareCall(“{CALL GETINFO(?)}”);<br>
        cstmt.setLong(1, 1309944422);<br>
        ResultSet rs = cstmt.executeQuery();<br>
        // process the results<br>
        while (rs.next()) {<br>
        ...<br>
        }<br>
        rs.close();<br>
        cstmt.close();<br>
        CODE EXAMPLE 13-24 Executing a CallableStatement object that returns a single result<br>
        set<br>
        The method executeQuery throws an SQLException if the stored procedure does<br>
        not return a ResultSet object.<br>
        13.3.3.2 Returning a Row Count<br>
        CODE EXAMPLE 13-25 shows the execution of a CallableStatement object that<br>
        returns a row count.<br>
        CallableStatement cstmt = conn.prepareCall(“{call GETCOUNT(?)}”);<br>
        cstmt.setString(1, “Smith”);<br>
        int count = cstmt.executeUpdate();<br>
        cstmt.close();<br>
        CODE EXAMPLE 13-25 Executing a CallableStatement object returning an update count<br>
        If the stored procedure does not return a row count, the method executeUpdate<br>
        throws an SQLException.<br>
        Chapter 13 Statements 107<br>
        13.3.3.3 Returning Unknown or Multiple Results<br>
        If the type or number of results returned by a CallableStatement object are not<br>
        known until run time, the CallableStatement object should be executed with the<br>
        method execute. The methods getMoreResults, getUpdateCount, and<br>
        getResultSet can be used to retrieve all the results.<br>
        The method execute returns true if the first result is a ResultSet object and<br>
        false if it is an update count.<br>
        When the method execute returns true, the method getResultSet is called to<br>
        retrieve the ResultSet object. When execute returns false, the method<br>
        getUpdateCount returns an int. If this number is greater than or equal to zero, it<br>
        indicates the number of rows that were affected by the statement. If it is -1, it<br>
        indicates that there are no more results.<br>
        If multiple results are being returned, the method getMoreResults can be called to<br>
        get the next result. As with the method execute, getMoreResults will return<br>
        true if the next result is a ResultSet object and false if the next result is a row<br>
        count or no more result are available.<br>
        CODE EXAMPLE 13-26 shows how to retrieve all the results from a<br>
        CallableStatment object.<br>
        CallableStatement cstmt = conn.prepareCall(procCall);<br>
        boolean retval = cstmt.execute();<br>
        ResultSet rs;<br>
        int count;<br>
        do {<br>
        if (retval == false) {<br>
        count = cstmt.getUpdateCount();<br>
        if (count == -1) {<br>
        // no more results<br>
        break;<br>
        } else {<br>
        // process row count<br>
        }<br>
        } else { // ResultSet<br>
        rs = cstmt.getResultSet();<br>
        // process ResultSet<br>
        }<br>
        retval = cstmt.getMoreResults();<br>
        Chapter 13 Statements 108<br>
        while (true);<br>
        CODE EXAMPLE 13-26 Executing a callable statement that returns multiple results<br>
        By default, each call to the method getMoreResults closes any previous<br>
        ResultSet object returned by the method getResultSet. However, the method<br>
        getMoreResults may take a parameter that specifies whether a ResultSet object<br>
        returned by getResultSet should be closed. The Statement interface defines<br>
        three constants that can be supplied to the method getMoreResults:<br>
        I CLOSE_CURRENT_RESULT — indicates that the current ResultSet object should<br>
        be closed when the next ResultSet object is returned<br>
        I KEEP_CURRENT_RESULT — indicates that the current ResultSet object should<br>
        not be closed when the next ResultSet object is returned<br>
        I CLOSE_ALL_RESULTS — indicates that any ResultSet objects that have been<br>
        kept open should be closed when the next result is returned<br>
        If the current result is an update count and not a ResultSet object, any parameter<br>
        passed to getMoreResults is ignored.<br>
        To determine whether a driver implements this feature, an application can call the<br>
        DatabaseMetaData method supportsMultipleOpenResults.<br>
        ResultSet rs1 = cstmt.getResultSet();<br>
        rs1.next();<br>
        ...<br>
        retval = cstmt.getMoreResults(Statement.KEEP_CURRENT_RESULT);<br>
        if (retval == true) {<br>
        ResultSet rs2 = cstmt.getResultSet();<br>
        rs2.next();<br>
        ...<br>
        rs1.next();<br>
        }<br>
        retval = cstmt.getMoreResults(Statement.CLOSE_ALL_RESULTS);<br>
        ...<br>
        CODE EXAMPLE 13-27 Keeping multiple results from a CallableStatement object open<br>
        Chapter 13 Statements 109<br>
        13.4 Escape Syntax<br>
        The SQL string used in a Statement object may include JDBC escape syntax. Escape<br>
        syntax allows the driver to more easily scan for syntax that requires special<br>
        processing. Implementing this special processing in the driver layer improves<br>
        application portability.<br>
        Special escape processing might be needed for the following:<br>
        I commonly used features that do not have standard syntax defined by SQL, or<br>
        where the native syntax supported by the underlying data source varies widely<br>
        among vendors. The driver may translate the escape syntax to a specific native<br>
        syntax in this case.<br>
        I features that are not supported by the underlying data source but are<br>
        implemented by the driver.<br>
        Escape processing for a Statement object is turned on or off using the method<br>
        setEscapeProcessing, with the default being on. The RowSet interface also<br>
        includes a setEscapeProcessing method. The RowSet method applies to the<br>
        SQL string used to populate a RowSet object. The setEscapeProcessing method<br>
        does not work for a PreparedStatement object because its SQL string may have<br>
        been precompiled when the PreparedStatement object was created.<br>
        JDBC defines escape syntax for the following:<br>
        I scalar functions<br>
        I date and time literals<br>
        I outer joins<br>
        I calling stored procedures<br>
        I escape characters for LIKE clauses<br>
        13.4.1 Scalar Functions<br>
        Almost all underlying data sources support numeric, string, time, date, system, and<br>
        conversion functions on scalar values. The escape syntax to access a scalar function<br>
        is:<br>
        {fn <function-name> (argument list)}<br>
            For example, the following code calls the function concat with two arguments to be<br>
            concatenated:<br>
            Chapter 13 Statements 110<br>
            {fn concat("Hot", "Java")}<br>
            The following syntax gets the name of the current database user:<br>
            {fn user()}<br>
            Scalar functions may be supported by different data sources with slightly different<br>
            native syntax, and they may not be supported by all drivers. The driver will either<br>
            map the escaped function call into the native syntax or implement the function<br>
            directly.<br>
            Various DatabaseMetaData methods list the functions that are supported. For<br>
            example, the method getNumericFunctions returns a comma-separated list of the<br>
            Open Group CLI names of numeric functions, the method getStringFunctions<br>
            returns string functions, and so on.<br>
            Refer to Appendix C “Scalar Functions" for a list of the scalar functions a driver is<br>
            expected to support. A driver is required to implement these functions only if the<br>
            data source supports them, however.<br>
            13.4.2 Date and Time Literals<br>
            Data sources differ widely in the syntax they use for date, time, and timestamp<br>
            literals. The JDBC API supports ISO standard format for the syntax of these literals,<br>
            using an escape clause that the driver translates to native syntax.<br>
            The escape syntax for date literals is:<br>
            {d 'yyyy-mm-dd'}<br>
            The driver will replace the escape clause with the equivalent native representation.<br>
            For example, the driver might replace {d ’1999-02-28’} with '28-FEB-99' if that<br>
            is the appropriate format for the underlying data source.<br>
            The escape syntax for TIME and TIMESTAMP literals are:<br>
            {t 'hh:mm:ss'}<br>
            {ts 'yyyy-mm-dd hh:mm:ss.f . . .'}<br>
            The fractional seconds ( .f . . . ) portion of the timestamp can be omitted.<br>
            13.4.3 Outer Joins<br>
            Outer joins are an advanced feature and are not supported by all data sources.<br>
            Consult relevant SQL documentation for an explanation of outer joins.<br>
            Chapter 13 Statements 111<br>
            The escape syntax for an outer join is:<br>
            {oj <outer-join>}<br>
                where <outer-join> has the form:<br>
                    table {LEFT|RIGHT|FULL} OUTER JOIN {table | <outer-join>} ON search-<br>
                        condition<br>
                        (Note that curly braces ( {} ) in the preceding line indicate that one of the items<br>
                        between them must be used; they are not part of the syntax.) The following SELECT<br>
                        statement uses the escape syntax for an outer join.<br>
                        Statement stmt = con.createStatement();<br>
                        stmt.executeQuery("SELECT * FROM {oj TABLE1 " +<br>
                        "LEFT OUTER JOIN TABLE2 ON DEPT_NO = 003420930}");<br>
                        The JDBC API provides three DatabaseMetaData methods for determining the<br>
                        kinds of outer joins a driver supports: supportsOuterJoins,<br>
                        supportsFullOuterJoins, and supportsLimitedOuterJoins.<br>
                        13.4.4 Stored Procedures<br>
                        If a database supports stored procedures, they can be invoked using JDBC escape<br>
                        syntax as follows:<br>
                        {call <procedure_name> [(<argument-list>)]}<br>
                            or, where a procedure returns a result parameter:<br>
                            {? = call <procedure_name> [(<argument-list>)]}<br>
                                The square brackets indicate that the (argument-list) portion is optional. Input<br>
                                arguments may be either literals or parameter markers. See “Setting Parameters” on<br>
                                page 103 for information on parameters.<br>
                                The method DatabaseMetaData.supportsStoredProcedures returns true if the<br>
                                database supports stored procedures.<br>
                                Chapter 13 Statements 112<br>
                                13.4.5 LIKE Escape Characters<br>
                                The percent sign ( % ) and underscore ( _ ) characters are wild card characters in SQL<br>
                                LIKE clauses ( % matches zero or more characters, and _ matches exactly one<br>
                                character). In order to interpret them literally, they can be preceded by a backslash<br>
                                ( \ ), which is a special escape character in strings. One can specify which character to<br>
                                use as the escape character by including the following syntax at the end of a query:<br>
                                {escape '<escape-character>'}<br>
                                    For example, the following query uses the backslash as an escape character, and<br>
                                    finds identifier names that begin with an underscore. Note that the Java compiler<br>
                                    will not recognize the backslash as a character unless it is preceded by a backslash.<br>
                                    stmt.executeQuery("SELECT name FROM Identifiers " +<br>
                                    "WHERE Id LIKE '\\_%' {escape '\\'}");<br>
                                    13.5 Performance Hints<br>
                                    The Statement interface has two methods that can be used to provide hints to a<br>
                                    JDBC driver: setFetchDirection and setFetchSize. The values supplied to<br>
                                    these methods are applied to each result set produced by the statement. The<br>
                                    methods of the same name in the ResultSet interface can be used to supply hints<br>
                                    for just that result set.<br>
                                    Hints provided to the driver via this interface may be ignored by the driver if they<br>
                                    are not appropriate.<br>
                                    The methods getFetchDirection and getFetchSize return the current value of<br>
                                    the hints. If either of these methods is called before the corresponding setter method<br>
                                    has been called, the value returned is implementation-defined.<br>
                                    13.6 Retrieving Auto Generated Keys<br>
                                    Many database systems have a mechanism that automatically generates a unique<br>
                                    key field when a row is inserted. The method Statement.getGeneratedKeys,<br>
                                    which can be called to retrieve the value of such a key, returns a ResultSet object<br>
                                    with a column for each automatically generated key. A flag indicating that any auto<br>
                                    Chapter 13 Statements 113<br>
                                    generated columns should be returned is passed to the methods execute,<br>
                                    executeUpdate or prepareStatement when the statement is executed or<br>
                                    prepared.<br>
                                    Statement stmt = conn.createStatement();<br>
                                    // indicate that the key generated is going to be returned<br>
                                    int rows = stmt.executeUpdate("INSERT INTO ORDERS " +<br>
                                    "(ISBN, CUSTOMERID) " +<br>
                                    "VALUES (195123018, ’BILLG’)",<br>
                                    Statement.RETURN_GENERATED_KEYS);<br>
                                    ResultSet rs = stmt.getGeneratedKeys();<br>
                                    boolean b = rs.next();<br>
                                    if (b == true) {<br>
                                    // retrieve the new key value<br>
                                    ...<br>
                                    }<br>
                                    CODE EXAMPLE 13-28 Retrieving auto generated keys<br>
                                    Additional methods allow the ordinals or names of the columns that should be<br>
                                    returned to be specified. In CODE EXAMPLE 13-29 the Statement method<br>
                                    executeUpdate is called with two parameters, the first is the SQL statement to be<br>
                                    executed, the second is an array of String containing the column name that should<br>
                                    be returned when getGeneratedKeys is called:<br>
                                    String keyColumn[] = {"ORDER_ID"};<br>
                                    ...<br>
                                    Statement stmt = conn.createStatement();<br>
                                    int rows = stmt.executeUpdate("INSERT INTO ORDERS " +<br>
                                    "(ISBN, CUSTOMERID) " +<br>
                                    "VALUES (966431502, ’BILLG’)",<br>
                                    keyColumn);<br>
                                    ResultSet rs = stmt.getGeneratedKeys();<br>
                                    ....<br>
                                    CODE EXAMPLE 13-29 Retrieving a named column using executeUpdate and<br>
                                    getGeneratedKeys<br>
                                    See the API Specification for more details.<br>
                                    Chapter 13 Statements 114<br>
                                    Calling ResultSet.getMetaData on the ResultSet object returned by<br>
                                    getGeneratedKeys will produce a ResultSetMetaData object that can be used<br>
                                    to determine the number, type and properties of the generated keys.<br>
                                    In some cases, such as in an insert select statement, more than one key may be<br>
                                    returned. The ResultSet object returned by getGeneratedKeys will contain a<br>
                                    row for each key that a statement generated. If no keys are generated, an empty<br>
                                    result set will be returned.<br>
                                    The concurrency of the ResultSet object returned by getGeneratedKeys must be<br>
                                    CONCUR_READ_ONLY. The type of the ResultSet object must be either<br>
                                    TYPE_FORWARD_ONLY or TYPE_SCROLL_INSENSITIVE.<br>
                                    The method DatabaseMetaData.supportsGetGeneratedKeys returns true if<br>
                                    a JDBC driver and underlying data source support the retrieval of automatically<br>
                                    generated keys.<br>
                                    Chapter 14 Result Sets 115<br>
                                    CHAPTER 14<br>
                                    Result Sets<br>
                                    The ResultSet interface provides methods for retrieving and manipulting the<br>
                                    results of executed queries.<br>
                                    14.1 Kinds of ResultSet Objects<br>
                                    ResultSet objects can have different functionality and characteristics. These<br>
                                    characteristics are result set type, result set concurrency, and cursor holdability.<br>
                                    14.1.1 ResultSet Types<br>
                                    The type of a ResultSet object determines the level of its functionality in two main<br>
                                    areas: (1) the ways in which the cursor can be manipulated and (2) how concurrent<br>
                                    changes made to the underlying data source are reflected by the ResultSet object.<br>
                                    The latter is called the sensitivity of the ResultSet object.<br>
                                    The three different ResultSet types are described below.<br>
                                    1.TYPE_FORWARD_ONLY<br>
                                    I The result set is not scrollable; its cursor moves forward only, from before the first<br>
                                    row to after the last row.<br>
                                    I The rows contained in the result set depend on how the underlying database<br>
                                    materializes the results. That is, it contains the rows that satisfy the query at<br>
                                    either the time the query is executed or as the rows are retrieved.<br>
                                    2. TYPE_SCROLL_INSENSITIVE<br>
                                    I The result set is scrollable; its cursor can move both forward and backward<br>
                                    relative to the current position, and it can move to an absolute position.<br>
                                    Chapter 14 Result Sets 116<br>
                                    I The result set is insensitive to changes made to the underlying data source while<br>
                                    it is open. It contains the rows that satisfy the query at either the time the query is<br>
                                    executed or as the rows are retrieved.<br>
                                    3. TYPE_SCROLL_SENSITIVE<br>
                                    I The result set is scrollable; its cursor can move both forward and backward<br>
                                    relative to the current position, and it can move to an absolute position.<br>
                                    I The result set reflects changes made to the underlying data source while the result<br>
                                    set remains open.<br>
                                    The default ResultSet type is TYPE_FORWARD_ONLY.<br>
                                    The method DatabaseMetaData.supportsResultSetType returns true if the<br>
                                    specified type is supported by the driver and false otherwise.<br>
                                    If the driver does not support the type supplied to the methods createStatement,<br>
                                    prepareStatement, or prepareCall, it generates an SQLWarning on the<br>
                                    Connection object that is creating the statement. When the statement is executed,<br>
                                    the driver returns a ResultSet object of a type that most closely matches the<br>
                                    requested type. An application can find out the type of a ResultSet object by<br>
                                    calling the method ResultSet.getType.<br>
                                    14.1.2 ResultSet Concurrency<br>
                                    The concurrency of a ResultSet object determines what level of update<br>
                                    functionality is supported.<br>
                                    The two concurrency levels are:<br>
                                    I CONCUR_READ_ONLY<br>
                                    The ResultSet object cannot be updated using the ResultSet interface.<br>
                                    I CONCUR_UPDATABLE<br>
                                    The ResultSet object can be updated using the ResultSet interface.<br>
                                    The default ResultSet concurrency is CONCUR_READ_ONLY.<br>
                                    The method DatabaseMetaData.supportsResultSetConcurrency returns<br>
                                    true if the specified concurrency level is supported by the driver and false<br>
                                    otherwise.<br>
                                    If the driver does not support the concurrency level supplied to the methods<br>
                                    createStatement, prepareStatement, or prepareCall, it generates an<br>
                                    SQLWarning on the Connection object that is creating the statement. An<br>
                                    application can find out the concurrency of a ResultSet object by calling the<br>
                                    method ResultSet.getConcurrency.<br>
                                    Chapter 14 Result Sets 117<br>
                                    If the driver cannot return a ResultSet object at the requested type and<br>
                                    concurrency, it determines the appropriate type before determining the concurrency.<br>
                                    14.1.3 ResultSet Holdability<br>
                                    Calling the method Connection.commit can close the ResultSet objects that<br>
                                    have been created during the current transaction. In some cases, however, this may<br>
                                    not be the desired behaviour. The ResultSet property holdability gives the<br>
                                    application control over whether ResultSet objects (cursors) are closed when a<br>
                                    commit operation is implicity or explictly performed.<br>
                                    The following ResultSet constants may be supplied to the Connection methods<br>
                                    createStatement, prepareStatement, and prepareCall:<br>
                                    1.HOLD_CURSORS_OVER_COMMIT<br>
                                    I ResultSet objects (cursors) are not closed; they are held open when a commit<br>
                                    operation is implicity or explicity performed.<br>
                                    2. CLOSE_CURSORS_AT_COMMIT<br>
                                    I ResultSet objects (cursors) are closed when a commit operation is implicity or<br>
                                    explicity performed. Closing cursors at commit can result in better performance<br>
                                    for some applications.<br>
                                    The default holdability of ResultSet objects is implementation defined. The<br>
                                    DatabaseMetaData method getResultSetHoldability can be called to<br>
                                    determine the default holdability of result sets returned by the underlying data<br>
                                    source.<br>
                                    14.1.4 Specifying ResultSet Type, Concurrency and<br>
                                    Holdability<br>
                                    The parameters supplied to the methods Connection.createStatement,<br>
                                    Connection.prepareStatement, and Connection.prepareCall determine<br>
                                    the type, concurrency, and holdability of ResultSet objects that the statement<br>
                                    produces. CODE EXAMPLE 14-1 creates a Statement object that will return scrollable,<br>
                                    read-only ResultSet objects that are insensitive to updates made to the data source<br>
                                    and that will be closed when the transaction in which they were created is<br>
                                    committed.<br>
                                    Connection conn = ds.getConnection(user, passwd);<br>
                                    Statement stmt = conn.createStatement(<br>
                                    ResultSet.TYPE_SCROLL_INSENSITIVE,<br>
                                    Chapter 14 Result Sets 118<br>
                                    ResultSet.CONCUR_READ_ONLY,<br>
                                    ResultSet.CLOSE_CURSORS_AT_COMMIT);<br>
                                    CODE EXAMPLE 14-1 Creating a scrollable, insensitive, read-only result set with a cursor<br>
                                    that is not holdable<br>
                                    The Statement, PreparedStatement and CallableStatement interfaces also<br>
                                    provide setter and getter methods for each of these properties.<br>
                                    14.2 Creating and Manipulating ResultSet<br>
                                    Objects<br>
                                    14.2.1 Creating ResultSet Objects<br>
                                    A ResultSet object is most often created as the result of executing a Statement<br>
                                    object. The Statement methods executeQuery and getResultSet both return a<br>
                                    ResultSet object, as do various DatabaseMetaData methods. CODE EXAMPLE 14-2<br>
                                    executes an SQL statement returning a ResultSet object.<br>
                                    Statement stmt = conn.createStatement();<br>
                                    ResultSet rs = stmt.executeQuery(“select author, title, isbn " +<br>
                                    "from booklist”);<br>
                                    CODE EXAMPLE 14-2 Executing a query returning a ResultSet object<br>
                                    For each book in the table booklist, the ResultSet object will contain a row<br>
                                    consisting of three columns, author, title, and isbn. The following sections detail<br>
                                    how these rows and columns can be retrieved.<br>
                                    14.2.2 Cursor Movement<br>
                                    A ResultSet object maintains a cursor, which points to its current row of data.<br>
                                    When a ResultSet object is first created, the cursor is positioned before the first<br>
                                    row. The following methods can be used to move the cursor:<br>
                                    I next() — moves the cursor forward one row. Returns true if the cursor is now<br>
                                    positioned on a row and false if the cursor is positioned after the last row.<br>
                                    Chapter 14 Result Sets 119<br>
                                    I previous() — moves the cursor backwards one row. Returns true if the cursor<br>
                                    is now positioned on a row and false if the cursor is positioned before the first<br>
                                    row.<br>
                                    I first() — moves the cursor to the first row in the ResultSet object. Returns<br>
                                    true if the cursor is now positioned on the first row and false if the<br>
                                    ResultSet object does not contain any rows.<br>
                                    I last() — moves the cursor to the last row in the ResultSet object. Returns<br>
                                    true if the cursor is now positioned on the last row and false if the ResultSet<br>
                                    object does not contain any rows.<br>
                                    I beforeFirst() — positions the cursor at the start of the ResultSet object,<br>
                                    before the first row. If the ResultSet object does not contain any rows, this<br>
                                    method has no effect.<br>
                                    I afterLast() — positions the cursor at the end of the ResultSet object, after<br>
                                    the last row. If the ResultSet object does not contain any rows, this method has<br>
                                    no effect.<br>
                                    I relative(int rows)— moves the cursor relative to its current position.<br>
                                    If rows is 0 (zero), the cursor is unchanged. If rows is positive, the cursor is moved<br>
                                    forward rows rows. If the cursor is less than the specified number of rows from<br>
                                    the last row, the cursor is positioned after the last row. If rows is negative, the<br>
                                    cursor is moved backward rows rows. If the cursor is less than rows rows from the<br>
                                    first row, the cursor is positioned before the first row.<br>
                                    The method relative returns true if the cursor is positioned on a valid row<br>
                                    and false otherwise.<br>
                                    If rows is 1, relative is identical to the method next. If rows is -1, relative is<br>
                                    identical to the method previous.<br>
                                    I absolute(int row)— positions the cursor on the row-th row of the<br>
                                    ResultSet object.<br>
                                    If row is positive, the cursor is moved row rows from the beginning of the<br>
                                    ResultSet object. The first row is 1, the second 2, and so on. If row is greater<br>
                                    than the number of rows in the ResultSet object, the cursor is positioned after<br>
                                    the last row.<br>
                                    If row is negative, the cursor is moved row rows from the end of the ResultSet<br>
                                    object. The last row is -1, the penultimate -2, and so on. If row is greater than the<br>
                                    number of rows in the ResultSet object, the cursor is positioned before the first<br>
                                    row.<br>
                                    Calling absolute(0) moves the cursor before the first row.<br>
                                    For a ResultSet object that is of type TYPE_FORWARD_ONLY, the only valid cursor<br>
                                    movement method is next. All other cursor movement methods throw an<br>
                                    SQLException.<br>
                                    Chapter 14 Result Sets 120<br>
                                    14.2.3 Retrieving Values<br>
                                    The ResultSet interface provides methods for retrieving the values of columns<br>
                                    from the row where the cursor is currently positioned.<br>
                                    Two getter methods exist for each JDBC type: one that takes the column index as its<br>
                                    first parameter and one that takes the column name or label.<br>
                                    The columns are numbered from left to right, as they appear in the select list of the<br>
                                    query, starting at 1.<br>
                                    Column names supplied to getter methods are case insensitive. If a select list<br>
                                    contains the same column more than once, the first instance of the column will be<br>
                                    returned.<br>
                                    The index of the first instance of a column name can be retrieved using the method<br>
                                    findColumn. If the specified column is not found, the method findColumn throws<br>
                                    an SQLException.<br>
                                    ResultSet rs = stmt.executeQuery(sqlstring);<br>
                                    int colIdx = rs.findColumn(“ISBN”);<br>
                                    CODE EXAMPLE 14-3 Mapping a column name to a column index<br>
                                    14.2.3.1 Data Type Conversions<br>
                                    The recommended ResultSet getter method for each JDBC type is shown in<br>
                                    TABLE B-6 on page B-182. This table also shows all of the possible conversions that a<br>
                                    JDBC driver may support. The method<br>
                                    DataBaseMetaData.supportsConvert(int fromType, int toType)<br>
                                    returns true if the driver supports the given conversion.<br>
                                    14.2.3.2 ResultSet Metadata<br>
                                    When the ResultSet method getMetaData is called on a ResultSet object, it<br>
                                    returns a ResultSetMetaData object describing the columns of that ResultSet<br>
                                    object. In cases where the SQL statement being executed is unkown until runtime,<br>
                                    the result set metadata can be used to determine which of the getter methods should<br>
                                    be used to retrieve the data. In CODE EXAMPLE 14-4 , result set metadata is used to<br>
                                    determine the type of each column in the result set.<br>
                                    Chapter 14 Result Sets 121<br>
                                    ResultSet rs = stmt.executeQuery(sqlString);<br>
                                    ResultSetMetaData rsmd = rs.getMetaData();<br>
                                    int colType [] = new int[rsmd.getColumnCount()];<br>
                                    for (int idx = 0, int col = 1; idx < colType.length; idx++, col++)<br>
                                    colType[idx] = rsmd.getColumnType(col);<br>
                                    CODE EXAMPLE 14-4 Retrieving result set metadata<br>
                                    14.2.3.3 Retrieving NULL values<br>
                                    The method wasNull can be called to determine if the last value retrieved was a<br>
                                    JDBC NULL in the database.<br>
                                    When the column value in the database is JDBC NULL, it may be returned to the Java<br>
                                    application as null, 0, or false, depending on the type of the column value.<br>
                                    Column values that map to Java Object types are returned as a Java null; those<br>
                                    that map to numeric types are returned as 0; those that map to a Java boolean are<br>
                                    returned as false. Therefore, it may be necessary to call the wasNull method to<br>
                                    determine whether the last value retrieved was a JDBC NULL.<br>
                                    14.2.4 Modifying ResultSet Objects<br>
                                    ResultSet objects with concurrency CONCUR_UPDATABLE can be updated using<br>
                                    ResultSet methods. Columns can be updated, new rows can be inserted, and rows<br>
                                    can be deleted using methods defined in the ResultSet interface.<br>
                                    14.2.4.1 Updating a Row<br>
                                    Updating a row in a ResultSet object is a two-phase process. First, the new value<br>
                                    for each column being updated is set, and then the change is applied to the row. The<br>
                                    row in the underlying data source is not updated until the second phase is<br>
                                    completed.<br>
                                    The ResultSet interface contains two update methods for each JDBC type, one<br>
                                    specifying the column to be updated as an index and one specifying the column<br>
                                    name as it appears in the select list.<br>
                                    Column names supplied to updater methods are case insensitive. If a select list<br>
                                    contains the same column more than once, the first instance of the column will be<br>
                                    updated.<br>
                                    Chapter 14 Result Sets 122<br>
                                    The method updateRow is used to apply all column changes to the current row. The<br>
                                    changes are not made to the row until updateRow has been called. The method<br>
                                    cancelUpdates can be used to back out changes made to the row before the<br>
                                    method updateRow is called. CODE EXAMPLE 14-5 shows the current row being<br>
                                    updated to change the value of the column “author” to “Zamyatin, Evgenii<br>
                                    Ivanovich”:<br>
                                    Statement stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,<br>
                                    ResultSet.CONCUR_UPDATABLE);<br>
                                    ResultSet rs = stmt.executeQuery(“select author from booklist " +<br>
                                    "where isbn = 140185852”);<br>
                                    rs.next();<br>
                                    rs.updateString(“author”, “Zamyatin, Evgenii Ivanovich”);<br>
                                    rs.updateRow();<br>
                                    CODE EXAMPLE 14-5 Updating a row in a ResultSet object<br>
                                    The method DatabaseMetaData.ownUpdatesAreVisible(int type) returns<br>
                                    true if a ResultSet object of the specified type is able to see its own updates and<br>
                                    false otherwise.<br>
                                    A ResultSet object may be able to use the method rowUpdated to detect rows<br>
                                    that have had the method updateRow called on them. The method<br>
                                    DatabaseMetaData.updatesAreDetected(int type) returns true if a<br>
                                    ResultSet object of the specified type can determine if a row is updated using the<br>
                                    method rowUpdated and false otherwise.<br>
                                    14.2.4.2 Deleting a Row<br>
                                    A row in a ResultSet object can be deleted using the method deleteRow.<br>
                                    CODE EXAMPLE 14-6 shows the fourth row of the ResultSet rs being deleted.<br>
                                    rs.absolute(4);<br>
                                    rs.deleteRow();<br>
                                    CODE EXAMPLE 14-6 Deleting a row in a ResultSet object<br>
                                    After the method deleteRow has been called, the current row is deleted in the<br>
                                    underlying data source. This deletion is visible as a change in the open ResultSet<br>
                                    object if the row is either removed or replaced by an empty or invalid row.<br>
                                    Chapter 14 Result Sets 123<br>
                                    If the deleted row is removed or replaced by an empty row, the method<br>
                                    DatabaseMetaData.ownDeletesAreVisible(int type) will return true. It<br>
                                    returns false if the ResultSet object still contains the deleted row, which means<br>
                                    that the deletion is not visible as a change to ResultSet objects of the given type.<br>
                                    The method DatabaseMetaData.othersDeletesAreVisible(int type)<br>
                                    checks whether deletions made by others (another transaction or another<br>
                                    ResultSet object in the same transaction) are visible to ResultSet objects of the<br>
                                    specified type. This method returns true if a row deleted by others is visible and<br>
                                    false if it is not.<br>
                                    If a ResultSet object can detect deletions, the ResultSet method rowDeleted<br>
                                    returns true when the current row has been deleted and false when it has not.<br>
                                    However, rowDeleted also returns false if the ResultSet object cannot detect<br>
                                    deletions. The method DatabaseMetaData.deletesAreDetected(int type)<br>
                                    can be called to see whether a ResultSet object of the specified type can call the<br>
                                    method rowDeleted to detect a deletion that is visible. The method<br>
                                    deletesAreDetected returns false if a row deleted from the ResultSet object<br>
                                    is removed from it and true if the deleted row is replaced by an empty or invalid<br>
                                    row.<br>
                                    In CODE EXAMPLE 14-7 , application code uses metadata to process a ResultSet<br>
                                    object that may contain deleted rows.<br>
                                    if (dbmd.ownDeletesAreVisible(ResultSet.TYPE_SCROLL_INSENSITIVE) &&<br>
                                    dbmd.deletesAreDetected(ResultSet.TYPE_SCROLL_INSENSITIVE)) {<br>
                                    while (rs.next) {<br>
                                    if (rs.rowDeleted()) {<br>
                                    continue;<br>
                                    } else {<br>
                                    // process row<br>
                                    ...<br>
                                    }<br>
                                    }<br>
                                    } else {<br>
                                    // if up-to-date data is needed, it is better to close this<br>
                                    // ResultSet object and reexecute the query to get an updated<br>
                                    // ResultSet object<br>
                                    ...<br>
                                    rs.close();<br>
                                    break;<br>
                                    Chapter 14 Result Sets 124<br>
                                    }<br>
                                    CODE EXAMPLE 14-7 Processing a ResultSet object containing deleted rows<br>
                                    Note – CODE EXAMPLE 14-7 does not cover the case where ownDeletesAreVisible<br>
                                    returns true and deletesAreDetected returns false. This will cause an<br>
                                    SQLException to be thrown when the cursor is positioned on a deleted row, so an<br>
                                    implementation with these characteristics requires that an application handle the<br>
                                    exception. Such an implementation does not appear to be a very likely.<br>
                                    After the method deleteRow has been called, the cursor will be positioned before<br>
                                    the next valid row. If the deleted row is the last row, the cursor will be positioned<br>
                                    after the last row.<br>
                                    14.2.4.3 Inserting a Row<br>
                                    New rows may be inserted using the ResultSet interface. New rows are<br>
                                    constructed in a special insert row. The steps to insert a new row are:<br>
                                    1. Move the cursor to the insert row<br>
                                    2. Set the values for the columns of the row using the ResultSet interface update<br>
                                    methods<br>
                                    3. Insert the new row into the ResultSet object<br>
                                    CODE EXAMPLE 14-8 shows the steps necessary to insert a new row into the table<br>
                                    booklist.<br>
                                    // select all the columns from the table booklist<br>
                                    ResultSet rs = stmt.executeQuery(“select author, title, isbn " +<br>
                                    "from booklist”);<br>
                                    rs.moveToInsertRow();<br>
                                    // set values for each column<br>
                                    rs.updateString(1, “Huxley, Aldous”);<br>
                                    rs.updateString(2, “Doors of Perception and Heaven and Hell”);<br>
                                    rs.updateLong(3, 60900075);<br>
                                    // insert the row<br>
                                    rs.insertRow();<br>
                                    // move the cursor back to its position in the result set<br>
                                    Chapter 14 Result Sets 125<br>
                                    rs.moveToCurrentRow();<br>
                                    CODE EXAMPLE 14-8 Inserting a new row into a ResultSet object<br>
                                    Each column in the insert row that does not allow null as a value and does not<br>
                                    have a default value must be given a value using the approriate update method. If<br>
                                    this is not the case, the method insertRow will throw an SQLException.<br>
                                    The method DatabaseMetaData.ownInsertsAreVisible(int type) will<br>
                                    return true if newly inserted rows can be seen in result sets of the specified type.<br>
                                    If the ResultSet objects of the specified type can identify newly inserted rows, the<br>
                                    method DatabaseMetaData.insertsAreDetected(int type) will return<br>
                                    true. This indicates that the inserted rows are visible to the ResultSet object.<br>
                                    14.2.4.4 Positioned Updates and Deletes<br>
                                    JDBC drivers or DBMSs that do not support performing updates via the ResultSet<br>
                                    interface may support positioned updates and deletes via SQL commands. This<br>
                                    method of updating a row relies on using named cursors to allow multiple<br>
                                    statements to act on a single result set. CODE EXAMPLE 14-9 shows the use of the<br>
                                    method setCursorName to associate a cursor with a Statement object and then<br>
                                    the use of the method getCursorName to retrieve the name for use by a second<br>
                                    Statement object.<br>
                                    Statement stmt1 = conn.createStatement();<br>
                                    stmt1.setCursorName(“CURSOR1”);<br>
                                    ResultSet rs = stmt1.executeQuery(“select author, title, isbn " +<br>
                                    "from booklist for update of author”);<br>
                                    // move to the row we want to update<br>
                                    while ( ... ) {<br>
                                    rs.next()<br>
                                    }<br>
                                    String cursorName = rs.getCursorName();<br>
                                    Statement stmt2 = conn.createStatement();<br>
                                    // now update the row<br>
                                    int updateCount = stmt2.executeUpdate("update booklist " +<br>
                                    "set author = ’Zamyatin, Evgenii Ivanovich’ " +<br>
                                    "where current of “ + cursorName);<br>
                                    CODE EXAMPLE 14-9 Updating a row using positioned updates<br>
                                    Chapter 14 Result Sets 126<br>
                                    The syntax of both the select statement and the update statement may vary among<br>
                                    driver or DBMS implementations.<br>
                                    The method DatabaseMetaData.supportsPositionedUpdates returns true if<br>
                                    the JDBC driver and DBMS support this facility.<br>
                                    14.2.5 Closing a ResultSet Object<br>
                                    A ResultSet object is automatically closed when the Statement object that<br>
                                    produced it is closed. The method close can be called explicitly to close a<br>
                                    ResultSet object, thereby releasing any external resources and making it<br>
                                    immediately available for garbage collection.<br>
                                    Chapter 15 Batch Updates 127<br>
                                    CHAPTER 15<br>
                                    Batch Updates<br>
                                    The batch update facility allows multiple update operations to be submitted to a<br>
                                    data source for processing at once. Submitting multiple updates together, instead of<br>
                                    individually, can greatly improve performance. Statement, PreparedStatement,<br>
                                    and CallableStatement objects can be used to submit batch updates.<br>
                                    15.1 Description of Batch Updates<br>
                                    15.1.1 Statements<br>
                                    The batch update facility allows a Statement object to submit a set of<br>
                                    heterogeneous update commands together as a single unit, or batch, to the<br>
                                    underlying data source.<br>
                                    Since the JDBC 2.0 API, a Statement object has had the ability to keep track of a list<br>
                                    of commands—or batch—that can be submitted together for execution. When a<br>
                                    Statement object is created, its associated batch is empty. An application adds<br>
                                    commands to a statement’s batch one at a time by calling the method<br>
                                    Statement.addBatch and providing it with the SQL update command to be<br>
                                    added. All of the commands added to a batch must be statements that return an<br>
                                    update count.<br>
                                    If an application decides not to submit a batch of updates that has been constructed<br>
                                    for a statement, it can call the method Statement.clearBatch to clear the batch<br>
                                    of all commands.<br>
                                    In CODE EXAMPLE 15-1 , all of the update operations required to insert a new<br>
                                    employee into a fictitious company database are submitted as a single batch.<br>
                                    Chapter 15 Batch Updates 128<br>
                                    // turn off autocommit<br>
                                    con.setAutoCommit(false);<br>
                                    Statement stmt = con.createStatement();<br>
                                    stmt.addBatch("INSERT INTO employees VALUES (1000, 'Joe Jones')");<br>
                                    stmt.addBatch("INSERT INTO departments VALUES (260, 'Shoe')");<br>
                                    stmt.addBatch("INSERT INTO emp_dept VALUES (1000, 260)");<br>
                                    // submit a batch of update commands for execution<br>
                                    int[] updateCounts = stmt.executeBatch();<br>
                                    CODE EXAMPLE 15-1 Creating and executing a batch of insert statements<br>
                                    In the example, auto-commit mode is disabled to prevent the driver from<br>
                                    committing the transaction when Statement.executeBatch is called. Disabling<br>
                                    auto-commit allows an application to decide whether or not to commit the<br>
                                    transaction in the event that an error occurs and some of the commands in a batch<br>
                                    cannot be processed successfully. For this reason, auto-commit should always be<br>
                                    turned off when batch updates are done. The commit behaviour of executeBatch<br>
                                    is always implementation-defined when an error occurs and auto-commit is true.<br>
                                    It is not possible to set a savepoint "within" a batch of statements to enable partial<br>
                                    recovery. If a savepoint is set any time before the method executeBatch is called,<br>
                                    it is set before any of the statements that have been added to the batch are executed.<br>
                                    Although the focus in this section is on using Statement objects to do batch<br>
                                    updates, the discussion that follows applies to PreparedStatment and<br>
                                    CallableStatement objects as well.<br>
                                    15.1.2 Successful Execution<br>
                                    The Statement.executeBatch method submits a statement’s batch to the<br>
                                    underlying data source for execution. Batch commands are executed serially (at least<br>
                                    logically) in the order in which they were added to the batch. When all of the<br>
                                    commands in a batch execute successfully, the method executeBatch returns an<br>
                                    integer array containing one entry for each command in the batch.<br>
                                    The entries in the array are ordered according to the order in which the commands<br>
                                    were processed (which, again, is the same as the order in which the commands were<br>
                                    originally added to the batch). When all of the commands in a batch have been<br>
                                    executed successfully, an entry in the array of update counts may have the following<br>
                                    values :<br>
                                    Chapter 15 Batch Updates 129<br>
                                    I 0 or greater — the command was processed successfully and the value is an<br>
                                    update count indicating the number of rows in the database that were affected by<br>
                                    the command’s execution<br>
                                    I Statement.SUCCESS_NO_INFO — the command was processed successfully, but<br>
                                    the number of rows affected is unknown<br>
                                    Calling the method executeBatch closes the calling Statement object’s current<br>
                                    result set if one is open. The statement’s batch is reset to empty once<br>
                                    executeBatch returns. The behaviour of the methods executeQuery,<br>
                                    executeUpdate, and execute is implementation-defined when a statement’s<br>
                                    batch is non-empty.<br>
                                    Only DDL and DML commands that return a simple update count may be executed<br>
                                    as part of a batch. The method executeBatch throws a BatchUpdateException<br>
                                    if any of the commands in the batch fail to execute properly or if a command<br>
                                    attempts to return a result set. When a BatchUpdateException is thrown, an<br>
                                    application can call the BatchUpdateException.getUpdateCounts method to<br>
                                    obtain an integer array of update counts that describes the outcome of the batch<br>
                                    execution.<br>
                                    15.1.3 Handling Failures during Execution<br>
                                    A JDBC driver may or may not continue processing the remaining commands in a<br>
                                    batch once execution of a command fails. However, a JDBC driver must always<br>
                                    provide the same behaviour with a particular data source. For example, a driver<br>
                                    cannot continue processing after a failure for one batch and not continue processing<br>
                                    for another batch.<br>
                                    If a driver stops processing after the first failure, the array returned by the method<br>
                                    BatchUpdateException.getUpdateCounts will always contain fewer entries<br>
                                    than there were statements in the batch. Since statements are executed in the order<br>
                                    that they are added to the batch, if the array contains N elements, this means that the<br>
                                    first N elements in the batch were processed successfully when executeBatch was<br>
                                    called.<br>
                                    When a driver continues processing in the presence of failures, the number of<br>
                                    elements in the array returned by the method<br>
                                    BatchUpdateException.getUpdateCounts always equals the number of<br>
                                    commands in the batch. When a BatchUpdateException object is thrown and the<br>
                                    driver continues processing after a failure, the array of update counts will contain<br>
                                    the following BatchUpdateException constant:<br>
                                    I Statement.EXECUTE_FAILED — the command failed to execute successfully.<br>
                                    This value is also returned for commands that could not be processed for some<br>
                                    reason—such commands fail implicitly.<br>
                                    Chapter 15 Batch Updates 130<br>
                                    JDBC drivers that do not continue processing after a failure never return<br>
                                    Statement.EXECUTE_FAILED in an update count array. Drivers of this type<br>
                                    simply return a status array containing an entry for each command that was<br>
                                    processed successfully.<br>
                                    A JDBC technology-based application can distinguish a JDBC driver that continues<br>
                                    processing after a failure from one that does not by examining the size of the array<br>
                                    returned by BatchUpdateException.getUpdateCounts. A JDBC driver that<br>
                                    continues processing always returns an array containing one entry for each element<br>
                                    in the batch. A JDBC driver that does not continue processing after a failure will<br>
                                    always return an array whose number of entries is less than the number of<br>
                                    commands in the batch.<br>
                                    15.1.4 PreparedStatement Objects<br>
                                    When a PreparedStatement object is used, a command in a batch consists of a<br>
                                    parameterized SQL statement and an associated set of parameters . The batch update<br>
                                    facility is used with a PreparedStatement object to associate multiple sets of<br>
                                    input parameter values with a single PreparedStatement object. The sets of<br>
                                    parameter values together with their associated parameterized update commands<br>
                                    can then be sent to the underlying data source engine for execution as a single unit.<br>
                                    CODE EXAMPLE 15-2 insertstwo new employee records into a database as a single<br>
                                    batch. The PreparedStatement interface setter methods are used to create each<br>
                                    parameter set, one for each employee. The PreparedStatement.addBatch<br>
                                    method adds a set of parameters to the current command.<br>
                                    // turn off autocommit<br>
                                    con.setAutoCommit(false);<br>
                                    PreparedStatement stmt = con.prepareStatement(<br>
                                    "INSERT INTO employees VALUES (?, ?)");<br>
                                    stmt.setInt(1, 2000);<br>
                                    stmt.setString(2, "Kelly Kaufmann");<br>
                                    stmt.addBatch();<br>
                                    stmt.setInt(1, 3000);<br>
                                    stmt.setString(2, "Bill Barnes");<br>
                                    stmt.addBatch();<br>
                                    Chapter 15 Batch Updates 131<br>
                                    // submit the batch for execution<br>
                                    int[] updateCounts = stmt.executeBatch();<br>
                                    CODE EXAMPLE 15-2 Creating and executing a batch of prepared statements<br>
                                    Finally, the method PreparedStatement.executeBatch is called to submit the<br>
                                    updates to the underlying data source. Calling this method clears the statement’s<br>
                                    associated list of commands. The array returned by<br>
                                    PreparedStatement.executeBatch contains an element for each set of<br>
                                    parameters in the batch, similar to the case for Statement objects. Each element<br>
                                    contains either an update count or the generic ‘success’ indicator<br>
                                    SUCCESS_NO_INFO.<br>
                                    Error handling in the case of PreparedStatement objects is the same as error<br>
                                    handling in the case of Statement objects. Some drivers may stop processing as<br>
                                    soon as an error occurs, while others may continue processing the rest of the batch.<br>
                                    As with Statement objects, the number of elements in the array returned by<br>
                                    BatchUpdateException.getUpdateCounts indicates whether or not the driver<br>
                                    continues processing after a failure. The same three array element values are<br>
                                    possible: 0 or higher, Statement.SUCCESS_NO_INFO, or<br>
                                    Statement.EXECUTE_FAILED. The order of the entries in the array is the same<br>
                                    order as the order in which commands were added to the batch.<br>
                                    15.1.5 CallableStatement Objects<br>
                                    The batch update facility works the same with CallableStatement objects as it<br>
                                    does with PreparedStatement objects. Multiple sets of input parameter values<br>
                                    may be associated with a CallableStatement object and sent to the underlying<br>
                                    data source together.<br>
                                    Stored procedures invoked using the batch update facility with a callable statement<br>
                                    must return a maximum of one update count. If no update count is returned, the<br>
                                    array element value will be Statement.SUCCESS_NO_INFO. Additionally, a<br>
                                    batchable stored procedure may not have OUT or INOUT parameters. The<br>
                                    CallableStatement.executeBatch method throws an exception if this<br>
                                    restriction is violated. Error handling is analogous to that for PreparedStatement<br>
                                    objects.<br>
                                    Chapter 15 Batch Updates 132<br>
                                    Chapter 16 Advanced Data Types 133<br>
                                    CHAPTER 16<br>
                                    Advanced Data Types<br>
                                    Chapter 16 “Advanced Data Types” and Chapter 17 “Customized Type Mapping”<br>
                                    discuss additions to the JDBC API that allow an application written in the Java<br>
                                    programming language to access SQL99 data types, such as binary large objects and<br>
                                    structured types. If a data source does not support an advanced data type described<br>
                                    in these two chapters, a driver for that data source is not required to implement the<br>
                                    methods and interfaces associated with that data type.<br>
                                    16.1 Taxonomy of SQL Types<br>
                                    The latest version of the ANSI/ ISO SQL standard is commonly referred to as SQL99.<br>
                                    The JDBC API incorporates a model of the new SQL99 data types that includes only<br>
                                    those properties that are essential to exchanging data between a database and an<br>
                                    application written in the Java programming language.<br>
                                    SQL99 specifies these data types:<br>
                                    I SQL92 built-in types—the familiar SQL ‘column types’<br>
                                    I CHAR<br>
                                    I FLOAT<br>
                                    I DATE<br>
                                    I and so on<br>
                                    I New built-in types — new types added by SQL99<br>
                                    I BOOLEAN — a truth value<br>
                                    I BLOB — a Binary Large OBject<br>
                                    I CLOB — a Character Large OBject<br>
                                    I User Defined Types<br>
                                    I Structured type — a user-defined type; for example:<br>
                                    Chapter 16 Advanced Data Types 134<br>
                                    CREATE TYPE PLANE_POINT AS (X FLOAT, Y FLOAT) NOT FINAL<br>
                                    I DISTINCT type — a user-defined type based on a built-in type; for example:<br>
                                    CREATE TYPE MONEY AS NUMERIC(10,2) FINAL<br>
                                    I Constructed types — new types based on a given base type<br>
                                    I REF(structured-type) — a pointer that persistently denotes an instance of<br>
                                    a structured type that resides in the database<br>
                                    I base-type ARRAY[n] — an array of n base-type elements<br>
                                    I Locators — new entities that are logical pointers to data that resides on the<br>
                                    database server. A LOCATOR exists in the client environment and is a transient,<br>
                                    logical pointer to data on the server. A locator typically refers to data that is too<br>
                                    large to materialize on the client, such as images or audio. There are operators<br>
                                    defined at the SQL level to retrieve random-access pieces of the data denoted by<br>
                                    the locator.<br>
                                    I LOCATOR(structured-type) — locator to a structured instance in server<br>
                                    I LOCATOR(array) — locator to an array in server<br>
                                    I LOCATOR(blob) — locator to a Binary Large Object in server<br>
                                    I LOCATOR(clob) — locator to a Character Large Object in server<br>
                                    I Type for managing data external to the data source<br>
                                    I Datalink — a reference to data external to the data source that is managed by<br>
                                    the data source. At the time of this writing, Datalink values are being<br>
                                    standardized as part of SQL MED (Management of External Data), a part of the<br>
                                    SQL ANSI/ ISO standard specification. Having the data source manage the<br>
                                    reference to external data has several advantages:<br>
                                    i. Referential integrity — the referenced data can no longer be deleted or<br>
                                    renamed directly through file system APIs<br>
                                    ii. Access control — access to the data may be configured such that it is<br>
                                    controlled by the data source instead of the file system<br>
                                    iii. Coordinated backup and recovery — data referenced by Datalink values<br>
                                    may be included in the data source’s backup process<br>
                                    iv. Transaction consistency — changes that affect both relational and external<br>
                                    data are executed in a transactional context to preserve the integrity and<br>
                                    consistency of the data<br>
                                    The remainder of this chapter discusses the default mechanism provided by the<br>
                                    JDBC API for accessing each of the new SQL data types mentioned above. The JDBC<br>
                                    API also provides a means of customizing the mapping of SQL DISTINCT and<br>
                                    structured types into Java classes. This mechanism is discussed in Chapter 17<br>
                                    “Customized Type Mapping”.<br>
                                    Chapter 16 Advanced Data Types 135<br>
                                    16.2 Mapping of SQL99 Types<br>
                                    The JDBC API provides default mappings for the new SQL99 types. Except for the<br>
                                    DISTINCT and DATALINK types, these default mappings take the form of interfaces.<br>
                                    The following list gives the SQL99 types and the interfaces to which they are<br>
                                    mapped.<br>
                                    I BLOB — the Blob interface<br>
                                    I CLOB — the Clob interface<br>
                                    I ARRAY — the Array interface<br>
                                    I Structured types — the Struct interface<br>
                                    I REF(structured type) — the Ref interface<br>
                                    The other SQL99 data types with default mappings to the Java programming<br>
                                    language are:<br>
                                    I DISTINCT — the type to which the base type is mapped. For example, a<br>
                                    DISTINCT value based on an SQL NUMERIC type maps to a<br>
                                    java.math.BigDecimal type because NUMERIC maps to BigDecimal in the<br>
                                    Java programming language.<br>
                                    I DATALINK — a java.net.URL object.<br>
                                    16.3 Blob and Clob Objects<br>
                                    16.3.1 Retrieving BLOB and CLOB Values<br>
                                    The binary large object (BLOB) and character large object (CLOB) data types are<br>
                                    treated similarly to the more primitive built-in types. Values of these types can be<br>
                                    retrieved by calling the getBlob and getClob methods in the ResultSet and<br>
                                    CallableStatement interfaces. For example, CODE EXAMPLE 16-1 retrieves a BLOB<br>
                                    value from the first column of the ResultSet rs and a CLOB value from the second<br>
                                    column.<br>
                                    Blob blob = rs.getBlob(1);<br>
                                    Clob clob = rs.getClob(2);<br>
                                    CODE EXAMPLE 16-1 Retrieving BLOB and CLOB values<br>
                                    Chapter 16 Advanced Data Types 136<br>
                                    The Blob interface contains operations for returning the length of the BLOB value, a<br>
                                    specific range of bytes contained in the BLOB value, and so on. The Clob interface<br>
                                    contains corresponding operations that are character based. The API documentation<br>
                                    gives more details.<br>
                                    An application does not deal directly with the LOCATOR(blob) and<br>
                                    LOCATOR(clob) types that are defined in SQL. By default, a JDBC driver should<br>
                                    implement the Blob and Clob interfaces using the appropriate locator type. Also by<br>
                                    default, Blob and Clob objects remain valid only during the transaction in which<br>
                                    they are created.<br>
                                    16.3.2 Storing Blob and Clob Objects<br>
                                    A Blob or Clob object can be passed as an input parameter to a<br>
                                    PreparedStatement object just like other data types. The method setBlob sets a<br>
                                    PreparedStatement parameter with a Blob object, and the method setClob sets<br>
                                    a Clob object as a parameter. In CODE EXAMPLE 16-2 , authorImage is an instance of<br>
                                    java.sql.Blob retrieved from another SQL statement, and authorBio is a an<br>
                                    instance of java.sql.Clob retrieved from another SQL statement.<br>
                                    PreparedStatement pstmt = conn.prepareStatement(<br>
                                    “INSERT INTO bio (image, text) VALUES (?, ?)");<br>
                                    pstmt.setBlob(1, authorImage);<br>
                                    pstmt.setClob(2, authorBio);<br>
                                    CODE EXAMPLE 16-2 Setting Blob and Clob objects as parameters to a<br>
                                    PreparedStatement object<br>
                                    The setBinaryStream and setObject methods may also be used to set a Blob<br>
                                    object as a parameter in a PreparedStatement object. The setAsciiStream,<br>
                                    setCharacterStream, and setObject methods are alternate means of setting a<br>
                                    Clob object as a parameter.<br>
                                    The updateBlob and updateClob methods can be used to update a column value<br>
                                    in an updatable result set.<br>
                                    16.3.3 Altering Blob and Clob Objects<br>
                                    The Blob and Clob interfaces provide methods to alter their internal content. In<br>
                                    CODE EXAMPLE 16-3 , the method setBytes is used to write the first five bytes of the<br>
                                    Blob object retrieved from the column DATA.<br>
                                    Chapter 16 Advanced Data Types 137<br>
                                    byte[] val = {0,1,2,3,4};<br>
                                    ...<br>
                                    Blob data = rs.getBlob(“DATA”);<br>
                                    int numWritten = data.setBytes(1, val);<br>
                                    if (dbmd.locatorsUpdateCopy() == true) {<br>
                                    PreparedStatement ps = conn.prepareStatement(<br>
                                    "UPDATE datatab SET data = ?");<br>
                                    ps.setBlob("DATA", data);<br>
                                    ps.executeUpdate();<br>
                                    }<br>
                                    CODE EXAMPLE 16-3 Writing bytes to a Blob object<br>
                                    Similarly, the Clob methods setString and truncate can be used to change the<br>
                                    value of a column containing a Clob object.<br>
                                    The semantics of updates made to LOB objects are implementation defined. In some<br>
                                    implementations, the changes may be made to a copy of the LOB, and in others the<br>
                                    changes are made directly to the LOB. In implementations where the changes are<br>
                                    made to a copy of the LOB, a separate update statement must be issued to update<br>
                                    the LOB stored in the DBMS.<br>
                                    The method locatorsUpdateCopy in the DatabaseMetaData interface returns<br>
                                    true if the implementation updates a copy of the LOB and false if updates are<br>
                                    made directly to the LOB. CODE EXAMPLE 16-3 shows a typical use of the<br>
                                    locatorsUpdateCopy method.<br>
                                    16.4 Array Objects<br>
                                    16.4.1 Retrieving Array Objects<br>
                                    Data of type SQL ARRAY can be retrieved by calling the getArray method of the<br>
                                    ResultSet and CallableStatement interfaces. For example, the following line<br>
                                    of code retrieves an Array value from the first column of the ResultSet rs .<br>
                                    Chapter 16 Advanced Data Types 138<br>
                                    Array a = rs.getArray(1);<br>
                                    By default, a JDBC driver should implement the Array interface using an SQL<br>
                                    LOCATOR(array) internally. Also by default, Array objects remain valid only<br>
                                    during the transaction in which they are created.<br>
                                    The Array object returned to an application by the ResultSet.getArray and<br>
                                    CallableStatement.getArray methods is a logical pointer to the SQL ARRAY<br>
                                    value in the database; it does not contain the contents of the SQL ARRAY value. The<br>
                                    Array interface provides several versions of the methods getArray and<br>
                                    getResultSet that return the contents of an SQL ARRAY value to the client as a<br>
                                    materialized Java programming language array ("Java array") or as a ResultSet<br>
                                    object. The API documentation gives complete details.<br>
                                    16.4.2 Storing Array Objects<br>
                                    The PreparedStatement methods setArray and setObject may be called to<br>
                                    pass an Array value as an input parameter to a PreparedStatement object.<br>
                                    CODE EXAMPLE 16-4 sets the Array object member_array , which was retrieved from<br>
                                    another table in the database, as the second parameter to the PreparedStatement<br>
                                    pstmt .<br>
                                    PreparedStatement pstmt = conn.prepareStatement(<br>
                                    "INSERT INTO dept (name, members) VALUES (?, ?)");<br>
                                    pstmt.setString(1, "biology");<br>
                                    pstmt.setArray(2, member_array);<br>
                                    pstmt.executeUpdate();<br>
                                    CODE EXAMPLE 16-4 Storing an Array object<br>
                                    A Java array may be passed as an input parameter by calling the method<br>
                                    PreparedSatement.setObject.<br>
                                    16.4.3 Updating Array Objects<br>
                                    The ResultSet methods updateArray and updateObject can be used to update<br>
                                    a column value.<br>
                                    CODE EXAMPLE 16-5 uses the method ResultSet.updateArray to update the value<br>
                                    of the column LATEST_NUMBERS in one ResultSet object with an Array object<br>
                                    retrieved from the column NUMBERS in another ResultSet object.<br>
                                    Chapter 16 Advanced Data Types 139<br>
                                    // retrieve a column containing an SQL ARRAY value from ResultSet rs<br>
                                    java.sql.Array num = rs.getArray("NUMBERS");<br>
                                    ...<br>
                                    // update the column "LATEST_NUMBERS" in a second ResultSet<br>
                                    // with the value retrieved...<br>
                                    rs2.updateArray("LATEST_NUMBERS", num);<br>
                                    rs2.updateRow();<br>
                                    CODE EXAMPLE 16-5 Updating a column with an Array object<br>
                                    16.5 Ref Objects<br>
                                    16.5.1 Retrieving REF Values<br>
                                    An SQL REF(structured type) value can be retrieved as a Ref object by calling<br>
                                    the getRef method of the ResultSet and CallableStatement interfaces. For<br>
                                    example, in CODE EXAMPLE 16-6 , the ResultSet rs contains a reference to an<br>
                                    instance of the SQL structured type dog that is stored in the table dogs. The code<br>
                                    retrieves this REF(dog) from the first column of rs.<br>
                                    ResultSet rs = stmt.executeQuery("SELECT oid FROM dogs WHERE " +<br>
                                    "name = rover");<br>
                                    rs.next();<br>
                                    Ref ref = rs.getRef(1);<br>
                                    CODE EXAMPLE 16-6 Retrieving a REF value<br>
                                    An SQL REF value is a pointer; therefore, a Ref object, which is the mapping of a<br>
                                    REF value, is likewise a pointer and does not contain the data of the structured type<br>
                                    instance to which it refers. A Ref object remains valid while the session or<br>
                                    connection on which it is created is open.<br>
                                    An SQL REF value may either be system-generated or user-generated. For user-<br>
                                    generated references, the representation of the reference values is based on a<br>
                                    predefined data type, such as INTEGER, and the reference values can be directly<br>
                                    inspected or generated by an end user or application. A vendor supporting user-<br>
                                    generated references may, in addition to the functionality based on the Ref object,<br>
                                    also support the retrieval and storage of reference values by using the getter and<br>
                                    setter methods that are appropriate to the representation type of the reference.<br>
                                    Chapter 16 Advanced Data Types 140<br>
                                    16.5.2 Retrieving the Referenced Value<br>
                                    The Ref object returned from the method getRef is a reference to an instance of a<br>
                                    structured type in the underlying data source. The methods getObject() and<br>
                                    getObject(Map map) can be used to retrieve the structured type instance that is<br>
                                    referenced. CODE EXAMPLE 16-7 shows how a reference to an instance of the<br>
                                    structured type Address can be dereferenced to retrieve the instance of Address.<br>
                                    This example would require that a map, mapping Address to its SQL type, had<br>
                                    been supplied to the Connection interface using the method setMap.<br>
                                    Ref ref = rs.getRef(1);<br>
                                    Address addr = (Address)ref.getObject();<br>
                                    CODE EXAMPLE 16-7 Retrieving the structured type instance referenced by a Ref object<br>
                                    16.5.3 Storing Ref Objects<br>
                                    The PreparedStatement.setRef method may be called to pass a Ref object as<br>
                                    an input parameter to a PreparedStatement object.<br>
                                    16.5.4 Storing the Referenced Value<br>
                                    An instance of a structured type retrieved with the method ResultSet.getRef or<br>
                                    CallableStatement.getRef is stored using the Ref.setObject method. In<br>
                                    CODE EXAMPLE 16-8 , the table DOGS stores instances of the structured type DOG. The<br>
                                    SELECT statement selects the REF(DOG) that refers to the instance in which the<br>
                                    name is Rover. The referenced instance of the type DOG is retrieved using<br>
                                    Ref.getObject. The parameter map describes a mapping from the SQL type DOG<br>
                                    to the Java class Dog, which implements the SQLData interface.<br>
                                    ResultSet rs = stmt.executeQuery("SELECT OID FROM DOGS " +<br>
                                    "WHERE NAME = ’ROVER’");<br>
                                    rs.next();<br>
                                    Ref rover = rs.getRef("OID");<br>
                                    Dog dog = (Dog)rover.getObject(map);<br>
                                    // manipulate instance of Dog<br>
                                    dog.setAge(14);<br>
                                    ...<br>
                                    // store updated Dog<br>
                                    rover.setObject((Object)dog);<br>
                                    Chapter 16 Advanced Data Types 141<br>
                                    CODE EXAMPLE 16-8 Retrieving and storing the structured type instance referenced by a<br>
                                    Ref object<br>
                                    16.5.5 Metadata<br>
                                    The type REF is defined in the class java.sql.Types. This value is returned by<br>
                                    methods such as DatabaseMetaData.getTypeInfo and<br>
                                    DatabaseMetaData.getColumns when a JDBC driver supports the Ref data<br>
                                    type.<br>
                                    16.6 Distinct Types<br>
                                    An SQL DISTINCT type is a new user-defined data type that is based on one of the<br>
                                    primitive types. C and C++ programmers can think of it as being similar to a<br>
                                    typedef.<br>
                                    16.6.1 Retrieving Distinct Types<br>
                                    By default, a column of SQL type DISTINCT is retrieved by calling any getter<br>
                                    method that is appropriate to the type on which it is based. For example, the<br>
                                    following type declaration creates the type MONEY, which is based on the SQL type<br>
                                    NUMERIC.<br>
                                    CREATE TYPE MONEY AS NUMERIC(10,2) FINAL<br>
                                    CODE EXAMPLE 16-9 Creating a distinct type<br>
                                    CODE EXAMPLE 16-10 uses the method getBigDecimal to retrieve a MONEY value<br>
                                    because the underlying SQL NUMERIC type is mapped to the<br>
                                    java.math.BigDecimal type.<br>
                                    java.math.BigDecimal bd = rs.getBigDecimal(1);<br>
                                    CODE EXAMPLE 16-10 Retrieving a distinct type<br>
                                    Chapter 16 Advanced Data Types 142<br>
                                    16.6.2 Storing Distinct Types<br>
                                    Any setter method in the PreparedStatement interface that is appropriate for the<br>
                                    base type of an SQL DISTINCT type may be used to pass an input parameter of that<br>
                                    distinct type to a prepared statement. For example, given the definition of type<br>
                                    MONEY in CODE EXAMPLE 16-9 , the method PreparedStatement.setBigDecimal<br>
                                    would be used.<br>
                                    16.6.3 Metadata<br>
                                    The type code DISTINCT is defined in the class java.sql.Types. This value is<br>
                                    returned by methods such as DatabaseMetaData.getTypeInfo and<br>
                                    DatabaseMetaData.getColumns when a JDBC driver supports this data type.<br>
                                    An SQL DISTINCT type must be defined as part of a particular database schema<br>
                                    before it can be used in a schema table definition. Information on schema-specific<br>
                                    user-defined types—of which DISTINCT types are one particular kind—can be<br>
                                    retrieved by calling the DatabaseMetaData.getUDTs method. For example,<br>
                                    CODE EXAMPLE 16-11 returns descriptions of all the SQL DISTINCT types defined in<br>
                                    the catalog-name.schema-name schema. If the driver does not support UDTs<br>
                                    or no matching UDTs are found, the getUDTs method returns an empty result set.<br>
                                    int[] types = {Types.DISTINCT};<br>
                                    ResultSet rs = dmd.getUDTs("catalog-name", "schema-name",<br>
                                    "%", types);<br>
                                    CODE EXAMPLE 16-11 Querying a DatabaseMetaData object for distinct types<br>
                                    Each row in the ResultSet object returned by the method getUDTs describes a<br>
                                    UDT. Each row contains the following columns:<br>
                                    TYPE_CAT<br>
                                    String => the type's catalog (may be null)<br>
                                    TYPE_SCHEM<br>
                                    String => the type's schema (may be null)<br>
                                    TYPE_NAME<br>
                                    String => the SQL type name<br>
                                    CLASS_NAME<br>
                                    String => a Java class name<br>
                                    DATA_TYPE<br>
                                    short => value defined in java.sql.Types, such as DISTINCT<br>
                                    REMARKS<br>
                                    String => explanatory comment on the type<br>
                                    BASE_TYPE<br>
                                    short => value defined in java.sql.Types, for DISTINCT or<br>
                                    reference types (may be null)<br>
                                    Chapter 16 Advanced Data Types 143<br>
                                    Most of the columns above should be self-explanatory. The TYPE_NAME is the SQL<br>
                                    type name given to the DISTINCT type—MONEY in the example above. This is the<br>
                                    name used in a CREATE TABLE statement to specify a column of this type.<br>
                                    When DATA_TYPE is Types.DISTINCT, the CLASS_NAME column contains a fully<br>
                                    qualified Java class name. Instances of this class will be created if getObject is<br>
                                    called on a column of this DISTINCT type. For example, CLASS_NAME would default<br>
                                    to java.math.BigDecimal in the case of MONEY above. The JDBC API does not<br>
                                    prohibit a driver from returning a subtype of the class named by CLASS_NAME. The<br>
                                    CLASS_NAME value reflects a custom type mapping when one is used. See<br>
                                    Chapter 17 “Customized Type Mapping” for details.<br>
                                    16.7 Structured Types<br>
                                    16.7.1 Retrieving Structured Types<br>
                                    An SQL structured type value is always retrieved by calling the method<br>
                                    getObject. By default, getObject returns a value of type Struct for a structured<br>
                                    type. For example, the following line of code retrieves a Struct value from the first<br>
                                    column of the current row of the ResultSet object rs.<br>
                                    Struct struct = (Struct)rs.getObject(1);<br>
                                    The Struct interface contains methods for retrieving the attributes of a structured<br>
                                    type as an array of java.lang.Object values. By default, a JDBC driver<br>
                                    materializes the contents of a Struct prior to returning a reference to it to the<br>
                                    application. Also, by default a Struct object is considered valid as long as the Java<br>
                                    application maintains a reference to it.<br>
                                    16.7.2 Storing Structured Types<br>
                                    The PreparedStatement.setObject method may be called to pass a Struct<br>
                                    object as an input parameter to a prepared statement.<br>
                                    Chapter 16 Advanced Data Types 144<br>
                                    16.7.3 Metadata<br>
                                    The type code STRUCT is defined in the class java.sql.Types. This value is<br>
                                    returned by methods such as DatabaseMetaData.getTypeInfo and<br>
                                    DatabaseMetaData.getColumns when a JDBC driver supports structured data<br>
                                    types.<br>
                                    An SQL structured type must be defined as part of a particular database schema<br>
                                    before it can be used in a schema table definition. Information on schema-specific<br>
                                    user-defined types—of which STRUCT types are one particular kind—can be<br>
                                    retrieved by calling the DatabaseMetaData.getUDTs method. For example,<br>
                                    CODE EXAMPLE 16-1 returns descriptions of all the SQL structured types defined in<br>
                                    the catalog-name.schema-name schema.<br>
                                    int[] types = {Types.STRUCT};<br>
                                    ResultSet rs = dmd.getUDTs("catalog-name", "schema-name",<br>
                                    "%", types);<br>
                                    CODE EXAMPLE 16-12 Querying a DatabaseMetaData object for structured types<br>
                                    If the driver does not support UDTs or no matching UDTs are found, an empty result<br>
                                    set is returned. See section 16.6.3 for a description of the result set returned by the<br>
                                    method getUDTs.<br>
                                    When the DATA_TYPE returned by getUDTs is Types.STRUCT, the CLASS_NAME<br>
                                    column contains the fully qualified Java class name of a Java class. Instances of this<br>
                                    class are manufactured by the JDBC driver when getObject is called on a column<br>
                                    of this STRUCT type. Thus, CLASS_NAME defaults to java.sql.Struct for<br>
                                    structured types. If there is a custom mapping for the STRUCT type, CLASS_NAME<br>
                                    will be the implementation of the interface SQLData that specifies the mapping. The<br>
                                    JDBC API does not prohibit a driver from returning a subtype of the class named by<br>
                                    CLASS_NAME. Chapter 17 “Customized Type Mapping” provides more information<br>
                                    about implementations of the SQLData interface.<br>
                                    16.8 Datalinks<br>
                                    A DATALINK value references a file outside of the underlying data source that the<br>
                                    data source manages.<br>
                                    Chapter 16 Advanced Data Types 145<br>
                                    16.8.1 Retrieving References to External Data<br>
                                    A reference to external data being managed by the data source can be retrieved<br>
                                    using the method ResultSet.getURL. The java.net.URL object that is returned<br>
                                    can be used to manipulate the data.<br>
                                    java.net.URL url = rs.getURL(1);<br>
                                    CODE EXAMPLE 16-13 Retrieving a reference to an external data object<br>
                                    In cases where the type of URL returned by the methods getObject or getURL is<br>
                                    not supported by the Java platform, the URL can be retrieved as a String by calling<br>
                                    the method getString.<br>
                                    16.8.2 Storing References to External Data<br>
                                    The method PreparedStatement.setURL can be used to pass a java.net.URL<br>
                                    object to a prepared statement. In cases where the type of URL being set is not<br>
                                    supported by the Java platform, the URL can be stored using the setString<br>
                                    method.<br>
                                    16.8.3 Metadata<br>
                                    The type code DATALINK is defined in the class java.sql.Types. This value is<br>
                                    returned by methods such as DatabaseMetaData.getTypeInfo and<br>
                                    DatabaseMetaData.getColumns when a JDBC driver supports the Datalink<br>
                                    data type or references to external files.<br>
                                    Chapter 16 Advanced Data Types 146<br>
                                    Chapter 17 Customized Type Mapping 147<br>
                                    CHAPTER 17<br>
                                    Customized Type Mapping<br>
                                    This chapter describes the support that the JDBC API provides for mapping SQL<br>
                                    structured and distinct types to classes in the Java programming language. Because<br>
                                    the mechanism for this custom mapping is an extension of the existing getObject<br>
                                    and setObject mechanism, it involves minimal extensions to the JDBC API from<br>
                                    the user’s point of view.<br>
                                    17.1 The Type Mapping<br>
                                    The SQL user-defined types (UDTs), structured types and DISTINCT types, can be<br>
                                    given a custom mapping to a class in the Java programming language. The default is<br>
                                    for a driver to use the default mappings between SQL data types and types in the<br>
                                    Java programming language. The default mapping for an SQL structured type is to<br>
                                    the interface Struct; the default mapping for an SQL DISTINCT type is to the type<br>
                                    to which the underlying type is mapped. If a custom mapping has been set up for a<br>
                                    UDT, the driver will use the custom mapping instead of the default mapping when<br>
                                    an application calls the getObject or setObject methods on that UDT.<br>
                                    Setting up a custom mapping requires two things:<br>
                                    1. Writing an implementation of the SQLData interface for the UDT. This class<br>
                                    typically maps the attribute(s) of an SQL structured type (or the single attribute of<br>
                                    a DISTINCT type) to fields. There is, however, great latitude allowed in how a<br>
                                    UDT is custom mapped. It is expected that most SQLData implementations will<br>
                                    be created using a tool.<br>
                                    2. Putting an entry in a java.util.Map object. The entry must contain the<br>
                                    following two items:<br>
                                    a. The fully qualified name of the SQL UDT that is to be mapped.<br>
                                    Chapter 17 Customized Type Mapping 148<br>
                                    b. The Class object for the SQLData implementation. It is an error if the class<br>
                                    listed in a type map entry does not implement the SQLData interface.<br>
                                    For example, if the UDT is named mySchemaName.AUTHORS and the SQLData<br>
                                    implementation is the class Authors, the entry for the type map associated with the<br>
                                    Connection object conn would look like CODE EXAMPLE 17-1 .<br>
                                    java.util.Map map = conn.getTypeMap();<br>
                                    map.put("mySchemaName.AUTHORS", Class.forName("Authors"));<br>
                                    conn.setTypeMap(map);<br>
                                    CODE EXAMPLE 17-1 Putting an entry in a connection’s type map<br>
                                    The method Connection.getTypeMap returns the type map associated with the<br>
                                    Connection object conn; the method Connection.setTypeMap sets the given<br>
                                    java.util.Map object as the type map for conn.<br>
                                    When an SQL value with a custom mapping is being retrieved (by the method<br>
                                    ResultSet.getObject, CallableStatement.getObject, or any of the other<br>
                                    methods that materialize an SQL value’s data on the client), the driver will check to<br>
                                    see if there is an entry in the connection’s type map for the SQL value that is to be<br>
                                    retrieved. If there is, the driver will map the SQL UDT to the class specified in the<br>
                                    type map. If there is no entry for the UDT in the connection’s type map, the UDT is<br>
                                    mapped to the default mapping.<br>
                                    Certain methods may take a type map as a parameter. A type map supplied as a<br>
                                    parameter supersedes the type map associated with the connection. A UDT that<br>
                                    does not have an entry in the type map supplied as a parameter will be mapped to<br>
                                    the default mapping. When a type map is explicitly supplied to a method, the<br>
                                    connection’s type map is never used.<br>
                                    17.2 Class Conventions<br>
                                    A class that appears in a type map entry must do the following:<br>
                                    1. Implement the interface java.sql.SQLData<br>
                                    2. Provide a niladic constructor, that is, a constructor that takes no parameters<br>
                                    The SQLData interface contains methods that convert instances of SQL UDTs to Java<br>
                                    class instances and that convert Java class instances back to SQL UDTs. For example,<br>
                                    the method SQLData.readSQL reads a stream of data values and builds a Java<br>
                                    Chapter 17 Customized Type Mapping 149<br>
                                    object, while the method SQLData.writeSQL writes a sequence of values from a<br>
                                    Java object to a stream. These methods will typically be generated by a tool that<br>
                                    understands the database schema.<br>
                                    This stream-based approach for exchanging data between SQL and the Java<br>
                                    programming language is conceptually similar to Java object serialization. The data<br>
                                    are read from and written to an SQL data stream provided by the JDBC driver. The<br>
                                    SQL data stream may be implemented on various network protocols and data<br>
                                    formats. It may be implemented on any logical data representation in which the leaf<br>
                                    SQL data items (of which SQL structured types are composed) can be read from<br>
                                    (written to) the data stream in a "depth-first" traversal of the structured types. That<br>
                                    is, each attribute value, which may itself be a structured type, appears fully (its<br>
                                    structure recursively elaborated) in the stream before the next attribute. In addition,<br>
                                    the attributes of an SQL structured type must appear in the stream in the order in<br>
                                    which they are declared in the type definition. For data of SQL structured types that<br>
                                    use inheritance, the attributes must appear in the stream in the order that they are<br>
                                    inherited. That is, the attributes of a supertype must appear before attributes of a<br>
                                    subtype.<br>
                                    If multiple inheritance is used, then the attributes of supertypes should appear in the<br>
                                    stream in the order in which the supertypes are listed in the type declaration. This<br>
                                    protocol does not require the database server to have any knowledge of the Java<br>
                                    programming language. However, as there is no support for multiple inheritance in<br>
                                    the SQL99 specification, this issue should not arise.<br>
                                    17.3 Streams of SQL Data<br>
                                    This section describes the stream interfaces, SQLInput and SQLOutput, which<br>
                                    support customization of the mapping of SQL UDTs to Java data types.<br>
                                    17.3.1 Retrieving Data<br>
                                    In a custom mapping, when data of SQL structured and distinct types are retrieved<br>
                                    from the database, they "arrive" in a stream implementing the SQLInput interface.<br>
                                    The SQLInput interface contains methods for reading individual data values<br>
                                    sequentially from the stream. CODE EXAMPLE 17-2 illustrates how a driver can use an<br>
                                    SQLInput stream to provide values for the fields of an SQLData object. The<br>
                                    SQLData object—the this object in the example—contains three persistent fields:<br>
                                    the String str , the Blob object blob, and the Employee object emp.<br>
                                    SQLInput sqlin;<br>
                                    ...<br>
                                    Chapter 17 Customized Type Mapping 150<br>
                                    this.str = sqlin.readString();<br>
                                    this.blob = sqlin.readBlob();<br>
                                    this.emp = (Employee)sqlin.readObject();<br>
                                    CODE EXAMPLE 17-2 Retrieving data using the SQLInput interface<br>
                                    The SQLInput.readString method reads a String value from the stream; the<br>
                                    SQLInput.readBlob method reads a Blob value from the stream. By default, the<br>
                                    Blob interface is implemented using an SQL locator, so calling the method<br>
                                    readBlob doesn’t materialize the SQL BLOB contents on the client. The<br>
                                    SQLInput.readObject method retrieves an object reference from the stream. In<br>
                                    the example, the Object returned is narrowed to an Employee object.<br>
                                    There are a number of additional methods defined on the SQLInput interface for<br>
                                    reading each of the types (readLong, readBytes, and so on). The<br>
                                    SQLInput.wasNull method can be called to check whether the last value read was<br>
                                    SQL NULL in the database.<br>
                                    17.3.2 Storing Data<br>
                                    When an instance of a class that implements SQLData is passed to a driver as an<br>
                                    input parameter via the setObject method, the JDBC driver calls the object’s<br>
                                    SQLData.writeSQL method. It also creates an SQLOutput stream to which the<br>
                                    method writeSQL writes the attributes of the custom mapped UDT. The method<br>
                                    writeSQL will typically have been generated by a tool from an SQL type definition.<br>
                                    CODE EXAMPLE 17-3 illustrates the use of the SQLOutput object sqlout.<br>
                                    sqlout.writeString(this.str);<br>
                                    sqlout.writeBlob(this.blob);<br>
                                    sqlout.writeObject(this.emp);<br>
                                    CODE EXAMPLE 17-3 Storing data using the SQLOutput interface<br>
                                    The example shows how the contents of an SQLData object can be written to an<br>
                                    SQLOutput stream. The SQLData object—the this object in the example—contains<br>
                                    three persistent fields: the String str, the Blob object blob, and the Employee<br>
                                    object emp. Each field is written in turn to the SQLOutput stream, sqlout. The<br>
                                    SQLOutput interface contains methods for writing each of the types defined in the<br>
                                    JDBC API.<br>
                                    Chapter 17 Customized Type Mapping 151<br>
                                    17.4 Examples<br>
                                    This section gives examples of SQL code as well as code in the Java programming<br>
                                    language. SQL code is used for creating structured types, creating tables for<br>
                                    instances of those types, populating the tables with instances of the structured types,<br>
                                    and creating an SQL DISTINCT type. This code sets up the SQL values that will be<br>
                                    mapped to classes in the Java programming language.<br>
                                    The examples of code in the Java programming language create implementations of<br>
                                    the SQLData interface for the newly created SQL UDTs and also show how a class in<br>
                                    the Java programming language can mirror SQL inheritance for structured types.<br>
                                    17.4.1 An SQL Structured Type<br>
                                    CODE EXAMPLE 17-4 , which defines the structured types PERSON, FULLNAME, and<br>
                                    RESIDENCE, shows that it is possible for an attribute to be a REF value or another<br>
                                    structured type. PERSON and RESIDENCE each have an attribute that is a REF value,<br>
                                    and the REF value in one structured type references the other structured type. Note<br>
                                    also that FULLNAME is used as an attribute of PERSON.<br>
                                    CREATE TYPE RESIDENCE AS<br>
                                    (<br>
                                    DOOR NUMERIC(6),<br>
                                    STREET VARCHAR(100),<br>
                                    CITY VARCHAR(50),<br>
                                    OCCUPANT REF(PERSON)<br>
                                    ) NOT FINAL<br>
                                    CREATE TYPE FULLNAME AS<br>
                                    (<br>
                                    FIRST VARCHAR(50),<br>
                                    LAST VARCHAR(50)<br>
                                    ) NOT FINAL<br>
                                    CREATE TYPE PERSON AS<br>
                                    (<br>
                                    NAME FULLNAME,<br>
                                    Chapter 17 Customized Type Mapping 152<br>
                                    HEIGHT NUMERIC,<br>
                                    WEIGHT NUMERIC,<br>
                                    HOME REF(RESIDENCE)<br>
                                    ) NOT FINAL<br>
                                    CODE EXAMPLE 17-4 Creating SQL structured types<br>
                                    The types created in CODE EXAMPLE 17-4 are presumed to be created in the current<br>
                                    schema for the following examples.<br>
                                    CODE EXAMPLE 17-5 creates two tables that are maintained by the DBMS<br>
                                    automatically. The CREATE statements do two things:<br>
                                    1. Create tables that store instances of the structured types named in the OF part of<br>
                                    the statement (RESIDENCE in the first one, PERSON in the second). Each of the<br>
                                    subsequent INSERT INTO statements adds a new row representing an instance of<br>
                                    the UDT.<br>
                                    2. Create a REF value that is a pointer to each instance that is inserted into the table.<br>
                                    As indicated in the CREATE statement, the REF value is generated by the system,<br>
                                    which is done implicitly. Because REF values are stored in the table, they are<br>
                                    persistent pointers. This contrasts with LOCATOR types, which are logical pointers<br>
                                    but exist only as long as the transactions in which they are created.<br>
                                    CREATE TABLE HOMES OF RESIDENCE<br>
                                    (REF IS OID SYSTEM GENERATED,<br>
                                    OCCUPANT WITH OPTIONS SCOPE PEOPLE)<br>
                                    CREATE TABLE PEOPLE OF PERSON<br>
                                    (REF IS OID SYSTEM GENERATED,<br>
                                    OCCUPANT WITH OPTIONS SCOPE HOMES)<br>
                                    CODE EXAMPLE 17-5 Creating tables to store instances of a structured type<br>
                                    CODE EXAMPLE 17-6 uses INSERT INTO statements to populate the tables created in<br>
                                    CODE EXAMPLE 17-5 . For example, the INSERT INTO PEOPLE statement inserts an<br>
                                    instance of the UDT PERSON into the table PEOPLE. When this command is executed,<br>
                                    the DBMS will also automatically generate a REF value that is a pointer to this<br>
                                    instance of PERSON and store it in the column OID (the column name specified in the<br>
                                    CREATE statement that created the table PEOPLE).<br>
                                    Each column value in these special tables is an attribute of the UDT, which may itself<br>
                                    be a UDT. For example, the first attribute of the UDT PERSON is the value in the<br>
                                    column NAME, which must be an instance of the UDT FULLNAME. The example<br>
                                    assumes that the UDT FULLNAME has an additional two-parameter constructor.<br>
                                    Chapter 17 Customized Type Mapping 153<br>
                                    A column value may also be a reference to an SQL structured type. For example, the<br>
                                    attribute OCCUPANT of the UDT RESIDENCE is of type REF(PERSON). It takes an<br>
                                    SQL SELECT statement to retrieve the REF value from the table HOMES and use it as<br>
                                    the value for OCCUPANT, which is shown at the end of CODE EXAMPLE 17-6 .<br>
                                    INSERT INTO PEOPLE (NAME, HEIGHT, WEIGHT) VALUES<br>
                                    (<br>
                                    NEW FULLNAME('DAFFY', 'DUCK'),<br>
                                    4,<br>
                                    58<br>
                                    );<br>
                                    INSERT INTO HOMES (DOOR, STREET, CITY, OCCUPANT) VALUES<br>
                                    (<br>
                                    1234,<br>
                                    'CARTOON LANE',<br>
                                    'LOS ANGELES',<br>
                                    (SELECT OID FROM PEOPLE P WHERE P.NAME.FIRST = 'DAFFY')<br>
                                    )<br>
                                    UPDATE PEOPLE SET HOME = (SELECT OID FROM HOMES H WHERE<br>
                                    H.OCCUPANT->NAME.FIRST = 'DAFFY') WHERE<br>
                                    FULLNAME.FIRST = 'DAFFY'<br>
                                    CODE EXAMPLE 17-6 Populating and updating tables that store instances of structured<br>
                                    types<br>
                                    17.4.2 SQLData Implementations<br>
                                    The Java classes defined in CODE EXAMPLE 17-7 are mappings of the SQL structured<br>
                                    types used in the examples in Section 17.4.1. We expect that such classes will<br>
                                    typically be generated by a tool that reads the definitions of those structured types<br>
                                    from the catalog tables and, subject to customizations that a user of the tool may<br>
                                    provide for name mappings and type mappings of primitive fields, will generate<br>
                                    Java classes like those in the example.<br>
                                    In each implementation of SQLData, the method SQLData.readSQL reads the<br>
                                    attributes in the order in which they appear in the SQL definition of the structured<br>
                                    type. Attributes are also read in "row order, depth-first" order, where the complete<br>
                                    Chapter 17 Customized Type Mapping 154<br>
                                    structure of each attribute is read recursively before the next attribute is read. The<br>
                                    method SQLData.writeSQL writes each attribute to the output stream in the same<br>
                                    order.<br>
                                    public class Residence implements SQLData {<br>
                                    public int door;<br>
                                    public String street;<br>
                                    public String city;<br>
                                    public Ref occupant;<br>
                                    private String sql_type;<br>
                                    public String getSQLTypeName() { return sql_type; }<br>
                                    public void readSQL (SQLInput stream, String type)<br>
                                    throws SQLException {<br>
                                    sql_type = type;<br>
                                    door = stream.readInt();<br>
                                    street = stream.readString();<br>
                                    city = stream.readString();<br>
                                    occupant = stream.readRef();<br>
                                    }<br>
                                    public void writeSQL (SQLOutput stream) throws SQLException {<br>
                                    stream.writeInt(door);<br>
                                    stream.writeString(street);<br>
                                    stream.writeString(city);<br>
                                    stream.writeRef(occupant);<br>
                                    }<br>
                                    }<br>
                                    public class Fullname implements SQLData {<br>
                                    public String first;<br>
                                    public String last;<br>
                                    private String sql_type;<br>
                                    public String getSQLTypeName() { return sql_type; }<br>
                                    Chapter 17 Customized Type Mapping 155<br>
                                    public void readSQL (SQLInput stream, String type)<br>
                                    throws SQLException {<br>
                                    sql_type = type;<br>
                                    first = stream.readString();<br>
                                    last = stream.readString();<br>
                                    }<br>
                                    public void writeSQL (SQLOutput stream) throws SQLException {<br>
                                    stream.writeString(first);<br>
                                    stream.writeString(last);<br>
                                    }<br>
                                    }<br>
                                    public class Person implements SQLData {<br>
                                    Fullname name;<br>
                                    float height;<br>
                                    float weight;<br>
                                    Ref home;<br>
                                    private String sql_type;<br>
                                    public String getSQLTypeName() { return sql_type; }<br>
                                    public void readSQL (SQLInput stream, String type)<br>
                                    throws SQLException {<br>
                                    sql_type = type;<br>
                                    name = (Fullname)stream.readObject();<br>
                                    height = stream.readFloat();<br>
                                    weight = stream.readFloat();<br>
                                    home = stream.readRef();<br>
                                    }<br>
                                    public void writeSQL (SQLOutput stream)<br>
                                    throws SQLException {<br>
                                    stream.writeObject(name);<br>
                                    stream.writeFloat(height);<br>
                                    stream.writeFloat(weight);<br>
                                    Chapter 17 Customized Type Mapping 156<br>
                                    stream.writeRef(home);<br>
                                    }<br>
                                    }<br>
                                    CODE EXAMPLE 17-7 Classes implementing the SQLData interface<br>
                                    CODE EXAMPLE 17-8 puts entries for custom mappings in the connection’s type map.<br>
                                    Then it retrieves the Ref instance stored in the OCCUPANT column of the table<br>
                                    HOMES. This Ref instance is set as a parameter in the where clause of the query to<br>
                                    get the name of the occupant. When the method getObject is called to retrieve an<br>
                                    instance of FULLNAME, the driver looks in the connections type map and uses the<br>
                                    SQLData implementation, Fullname, to custom map the FULLNAME value.<br>
                                    // set up mappings for the connection<br>
                                    try {<br>
                                    java.util.Map map = con.getTypeMap();<br>
                                    map.put(“S.RESIDENCE", Class.forName("Residence"));<br>
                                    map.put("S.FULLNAME", Class.forName("Fullname"));<br>
                                    map.put("S.PERSON", Class.forName("Person"));<br>
                                    }<br>
                                    catch (ClassNotFoundException ex) {}<br>
                                    PreparedStatement pstmt;<br>
                                    ResultSet rs;<br>
                                    pstmt = con.prepareStatement("SELECT OCCUPANT FROM HOMES");<br>
                                    rs = pstmt.executeQuery();<br>
                                    rs.next();<br>
                                    Ref ref = rs.getRef(1);<br>
                                    pstmt = con.prepareStatement(<br>
                                    "SELECT FULLNAME FROM PEOPLE WHERE OID = ?");<br>
                                    pstmt.setRef(1, ref);<br>
                                    rs = pstmt.executeQuery(); rs.next();<br>
                                    Fullname who = (Fullname)rs.getObject(1);<br>
                                    // prints "Daffy Duck"<br>
                                    System.out.println(who.first + " " + who.last);<br>
                                    CODE EXAMPLE 17-8 Retrieving a custom mapping<br>
                                    Chapter 17 Customized Type Mapping 157<br>
                                    17.4.3 Mirroring SQL Inheritance in the Java<br>
                                    Programming Language<br>
                                    SQL structured types may be defined to form an inheritance hierarchy. For example,<br>
                                    consider SQL type STUDENT, which inherits from PERSON:<br>
                                    CREATE TYPE PERSON AS<br>
                                    (NAME VARCHAR(20),<br>
                                    BIRTH DATE)<br>
                                    NOT FINAL;<br>
                                    CREATE TYPE STUDENT UNDER PERSON AS<br>
                                    (GPA NUMERIC(4,2))<br>
                                    NOT FINAL;<br>
                                    CODE EXAMPLE 17-9 Creating a hierarchy of SQL types<br>
                                    The following Java classes can represent data of those SQL types. Class Student<br>
                                    extends Person, mirroring the SQL type hierarchy. Methods SQLData.readSQL<br>
                                    and SQLData.writeSQL of the subclass cascade each call to the corresponding<br>
                                    method in its superclass in order to read or write the superclass attributes before<br>
                                    reading or writing the subclass attributes.<br>
                                    import java.sql.*;<br>
                                    ...<br>
                                    public class Person implements SQLData {<br>
                                    public String name;<br>
                                    public Date birth;<br>
                                    private String sql_type;<br>
                                    public String getSQLTypeName() { return sql_type; }<br>
                                    public void readSQL (SQLInput data, String type)<br>
                                    throws SQLException {<br>
                                    sql_type = type;<br>
                                    name = data.readString();<br>
                                    birth = data.readDate();<br>
                                    }<br>
                                    public void writeSQL (SQLOutput data)<br>
                                    Chapter 17 Customized Type Mapping 158<br>
                                    throws SQLException {<br>
                                    data.writeString(name);<br>
                                    data.writeDate(birth);<br>
                                    }<br>
                                    }<br>
                                    public class Student extends Person {<br>
                                    public float GPA;<br>
                                    private String sql_type;<br>
                                    public String getSQLTypeName() { return sql_type; }<br>
                                    public void readSQL (SQLInput data, String type)<br>
                                    throws SQLException {<br>
                                    sql_type = type;<br>
                                    super.readSQL(data, type);<br>
                                    GPA = data.readFloat();<br>
                                    }<br>
                                    public void writeSQL (SQLOutput data)<br>
                                    throws SQLException {<br>
                                    super.writeSQL(data);<br>
                                    data.writeFloat(GPA);<br>
                                    }<br>
                                    }<br>
                                    CODE EXAMPLE 17-10 Mirroring SQL type hierarchies in Java classes<br>
                                    The Java class hierarchy need not mirror the SQL inheritance hierarchy. For example,<br>
                                    the class Student above could have been declared without a superclass. In this<br>
                                    case, Student could contain fields to hold the inherited attributes of the SQL type<br>
                                    STUDENT as well as the attributes declared by STUDENT itself.<br>
                                    17.4.4 Example Mapping of SQL DISTINCT Type<br>
                                    CODE EXAMPLE 17-11 illustrates creating an SQL DISTINCT type, MONEY, and<br>
                                    CODE EXAMPLE 17-12 illustrates a Java class, Money, that represents it.<br>
                                    Chapter 17 Customized Type Mapping 159<br>
                                    CREATE TYPE MONEY AS NUMERIC(10,2) FINAL;<br>
                                    CODE EXAMPLE 17-11 Creating an SQL DISTINCT type<br>
                                    public class Money implements SQLData {<br>
                                    public java.math.BigDecimal value;<br>
                                    private String sql_type;<br>
                                    public String getSQLTypeName() { return sql_type; }<br>
                                    public void readSQL (SQLInput stream, String type)<br>
                                    throws SQLException {<br>
                                    sql_type = type;<br>
                                    value = stream.readBigDecimal();<br>
                                    }<br>
                                    public void writeSQL (SQLOutput stream) throws SQLException {<br>
                                    stream.writeBigDecimal(value);<br>
                                    }<br>
                                    }<br>
                                    CODE EXAMPLE 17-12 Java class that represents a DISTINCT type<br>
                                    17.5 Effect of Transform Groups<br>
                                    Transform groups (SQL99) can be used to convert a user-defined SQL type into<br>
                                    predefined SQL types. This transformation is performed by the underlying data<br>
                                    source before it is returned to the JDBC driver.<br>
                                    If transform groups are used for a user-defined type, and the application has not<br>
                                    defined a mapping for that type to a Java class, then the ResultSetMetaData<br>
                                    method getColumnClass should return the Java class corresponding to the data<br>
                                    type produced by the transformation function (that is, String for a VARCHAR).<br>
                                    Note – This is consistent with the behaviour for DISTINCT types.<br>
                                    Chapter 17 Customized Type Mapping 160<br>
                                    If transform groups are used for a UDT, and the application has defined a mapping<br>
                                    for that type to a Java class, then the SQLInput stream delivered by the JDBC driver<br>
                                    during an invocation of the method readSQL contains only a single value, that is,<br>
                                    the result produced by the transformation function. The same model holds for the<br>
                                    method writeSQL.<br>
                                    17.6 Generality of the Approach<br>
                                    Users have great flexibility in customizing the Java classes that represent SQL<br>
                                    structured and DISTINCT types. They control the mappings of built-in SQL attribute<br>
                                    types to Java field types. They control the mappings of SQL names (of types and<br>
                                    attributes) to Java names (of classes and fields). Users may add (to Java classes that<br>
                                    represent SQL types) fields and methods that implement domain-specific<br>
                                    functionality. Users can generate JavaBeans components as the classes that represent<br>
                                    SQL types.<br>
                                    A user can even map a single SQL type to different Java classes, depending on<br>
                                    arbitrary conditions. To do that, the user must customize the implementation of<br>
                                    SQLData.readSQL to construct and return objects of different classes under<br>
                                    different conditions.<br>
                                    Similarly, the user can map a single SQL value to a graph of Java objects. Again, that<br>
                                    is accomplished by customizing the implementation of the method<br>
                                    SQLData.readSQL to construct multiple objects and distribute the SQL attributes<br>
                                    into fields of those objects.<br>
                                    A customization of the SQLData.readSQL method could populate a connection’s<br>
                                    type map incrementally. This flexibility will allow users to map SQL types<br>
                                    appropriately for different kinds of applications.<br>
                                    17.7 NULL Data<br>
                                    An application uses the existing getObject and setObject mechanism to retrieve<br>
                                    and store SQLData values. We note that when the second parameter, x, of method<br>
                                    PreparedStatement.setObject has the value null, the driver executes the SQL<br>
                                    statement as if the SQL literal NULL had appeared in its place.<br>
                                    void setObject (int i, Object x) throws SQLException;<br>
                                    Chapter 17 Customized Type Mapping 161<br>
                                    When parameter x is null, there is no enforcement that the corresponding<br>
                                    argument expression is of a Java type that could successfully be passed to that SQL<br>
                                    statement if its value were not null. The Java programming language null carries<br>
                                    no type information. For example, a null Java programming language variable of<br>
                                    class AntiMatter could be passed as an argument to an SQL statement that<br>
                                    requires a value of SQL type MATTER, and no error would result, even though the<br>
                                    relevant type map object did not permit the translation of MATTER to AntiMatter.<br>
                                    Chapter 17 Customized Type Mapping 162<br>
                                    Chapter 18 Rowsets 163<br>
                                    CHAPTER 18<br>
                                    Rowsets<br>
                                    A javax.sql.RowSet object encapsulates a set of rows that have been retrieved<br>
                                    from a tabular data source. Because the RowSet interface includes an event<br>
                                    notification mechanism and supports getting and setting properties, every RowSet<br>
                                    object is a JavaBeans TM component. This means, for example, that a rowset can be<br>
                                    used as a JavaBeans component in a visual JavaBeans development environment. As<br>
                                    a result, a RowSet instance can be created and configured at design time, and its<br>
                                    methods can be executed at run time.<br>
                                    18.1 Rowsets at Design Time<br>
                                    18.1.1 Properties<br>
                                    The RowSet interface provides a set of JavaBeans properties that allow a RowSet<br>
                                    instance to be configured to connect to a data source and retrieve a set of rows.<br>
                                    CODE EXAMPLE 18-1 sets some properties for the RowSet object rset.<br>
                                    rset.setDataSourceName("jdbc/SomeDataSourceName");<br>
                                    rset.setTransactionIsolation(<br>
                                    Connection.TRANSACTION_READ_COMMITTED);<br>
                                    rset.setCommand("SELECT NAME, BREED, AGE FROM CANINE");<br>
                                    CODE EXAMPLE 18-1 Setting properties for a RowSet object<br>
                                    The data source name property is used by a RowSet object to look up a<br>
                                    DataSource object in a JNDI naming service. (Relational databases are the most<br>
                                    common type of data source used by rowsets.) The DataSource object is used to<br>
                                    create a connection to the physical data source that it represents. The transaction<br>
                                    Chapter 18 Rowsets 164<br>
                                    isolation property specifies that only data that was produced by committed<br>
                                    transactions may be read by the rowset. Lastly, the command property specifies the<br>
                                    command that will be executed to retrieve a set of rows. In this case, the NAME,<br>
                                    BREED, and AGE columns for all rows in the CANINE table are retrieved.<br>
                                    18.1.2 Events<br>
                                    RowSet components support JavaBeans events, which allows other JavaBeans<br>
                                    components in an application to be notified when an event on a rowset occurs. A<br>
                                    component that wishes to register for RowSet events must implement the<br>
                                    RowSetListener interface. Event listeners are registered with a rowset by calling<br>
                                    the addRowSetListener method as shown below. Any number of listeners may be<br>
                                    registered with an individual RowSet object. CODE EXAMPLE 18-2 adds one listener to<br>
                                    the RowSet object rset.<br>
                                    RowSetListener listener = ...;<br>
                                    rset.addRowSetListener(listener);<br>
                                    CODE EXAMPLE 18-2 Adding a listener to a RowSet object<br>
                                    Rowsets can generate three different types of events:<br>
                                    1. Cursor movement events — indicate that the rowset’s cursor has moved<br>
                                    2. Row change events — indicate that a particular row has been inserted, updated or<br>
                                    deleted<br>
                                    3. Rowset change events — indicate that the entire contents of a rowset have<br>
                                    changed, which may happen, for example, when the method RowSet.execute<br>
                                    is called.<br>
                                    When an event occurs, the appropriate listener method is called behind the scenes to<br>
                                    notify the registered listener(s). If a listener is not interested in a particular kind of<br>
                                    event, it may implement the method for that event so that it does nothing. Listener<br>
                                    methods take a RowSetEvent object, which identifies the RowSet object that is the<br>
                                    source of the event.<br>
                                    Chapter 18 Rowsets 165<br>
                                    18.2 Rowsets at Run Time<br>
                                    18.2.1 Parameters<br>
                                    The command property in CODE EXAMPLE 18-1 was set with a simple SQL command<br>
                                    that takes no input parameters, but it could also have been set with a command that<br>
                                    accepts input parameters. The RowSet interface provides a group of setter methods<br>
                                    for setting these input parameters.<br>
                                    CODE EXAMPLE 18-3 shows a command that takes a String input parameter. The<br>
                                    RowSet.setString method is used to pass the input parameter value to the<br>
                                    RowSet object rset . Typically, the command property is specified at design time,<br>
                                    whereas parameters are not set until run time when their values are known.<br>
                                    rset.setCommand("SELECT NAME, BREED, AGE FROM CANINE WHERE NAME = ?");<br>
                                    rset.setString(1, "spot");<br>
                                    CODE EXAMPLE 18-3 Setting parameters in a RowSetobject’s command<br>
                                    18.2.2 Command Execution<br>
                                    A rowset may be filled with data by calling the RowSet.execute method. This<br>
                                    method uses the appropriate property values internally to connect to a data source<br>
                                    and retrieve some data. The RowSet interface includes the properties that are<br>
                                    needed to connect to a data source. The exact properties that must be set may vary<br>
                                    between RowSet implementations, so developers need to check the documentation<br>
                                    for the particular rowset they are using. The method execute throws an<br>
                                    SQLException if the necessary properties have not been set. The current contents of<br>
                                    a rowset, if any, are lost when the method execute is called.<br>
                                    18.2.3 Traversing a Rowset<br>
                                    The javax.sql.RowSet interface extends the java.sql.ResultSet interface, so<br>
                                    in many ways a rowset behaves just like a result set. In fact, most components that<br>
                                    make use of a RowSet component will likely treat it as a ResultSet object. A<br>
                                    RowSet object is simply a ResultSet object that can function as a JavaBeans<br>
                                    Chapter 18 Rowsets 166<br>
                                    component. The code below shows how to iterate forward through a rowset. Notice<br>
                                    that since a rowset is a result set, this code is identical to the code that would be<br>
                                    used to iterate forward through a result set.<br>
                                    // iterate forward through the rowset<br>
                                    rset.beforeFirst();<br>
                                    while (rset.next()) {<br>
                                    System.out.println(rset.getString(1) + " " + rset.getFloat(2));<br>
                                    }<br>
                                    CODE EXAMPLE 18-4 Printing all the rows in a two-column RowSet object<br>
                                    Other cursor movements, such as iterating backward through the rowset and<br>
                                    positioning the cursor on a specific row, are also done the same way they are for<br>
                                    result sets.<br>
                                    Chapter 19 Relationship to Connectors 167<br>
                                    CHAPTER 19<br>
                                    Relationship to Connectors<br>
                                    The J2EE Connector Architecture 1.0 Specification defines a set of contracts that<br>
                                    allow a resource adapter to extend a container in a pluggable way. A resource<br>
                                    adapter provides connectivity to an external system from the application server. The<br>
                                    resource adapter’s functionality is similar to that provided by the JDBC interfaces<br>
                                    used in the J2EE platform to establish a connection with a data source. These<br>
                                    interfaces, which the Connector specification refers to as the service provider interface<br>
                                    (SPI), are the following:<br>
                                    I DataSource<br>
                                    I ConnectionPoolDataSource<br>
                                    I XADataSource<br>
                                    Additionally, the Connector Architecture defines a packaging format to allow a<br>
                                    resource adapter to be deployed into a J2EE compliant application server.<br>
                                    19.1 System Contracts<br>
                                    The system contracts defined in the Connector specification describe the interface<br>
                                    between an application server and one or more resource adapters. This interface<br>
                                    allows a resource adapter to be bundled in such a way that it can be used by any<br>
                                    application server that supports the system contracts.<br>
                                    The following standard contracts are defined between an application server and a<br>
                                    back end system:<br>
                                    I A connection management contract that enables application components to<br>
                                    connect to a back end system.<br>
                                    The connection management contract is equivalent to the services described by<br>
                                    the JDBC interfaces DataSource and ConnectionPoolDataSource.<br>
                                    Chapter 19 Relationship to Connectors 168<br>
                                    I A transaction management contract between the transaction manager and a back<br>
                                    end system supporting transactional access to its resources.<br>
                                    The transaction contract is equivalent to the services described by the JDBC<br>
                                    interface XADataSource.<br>
                                    I A security contract that enables secure access to a back end system.<br>
                                    The security contract does not have an equivalent in the JDBC API.<br>
                                    Authentication in the JDBC API always consists of providing a user name and a<br>
                                    password.<br>
                                    The JDBC specification does not make a distinction between its application<br>
                                    programming interface (API) and the SPI. However, a driver can map the JDBC<br>
                                    interfaces in the SPI to the Connector system contracts.<br>
                                    19.2 Mapping Connector System Contracts to<br>
                                    JDBC Interfaces<br>
                                    Driver vendors who want to supply JDBC drivers that use the Connector system<br>
                                    contracts have several options:<br>
                                    1. To write a set of classes that wrap a JDBC driver and implement the Connector<br>
                                    system contracts. Constructing these wrappers is fairly straightforward and<br>
                                    should allow JDBC driver vendors to provide resource adapters quickly enough<br>
                                    so that they are available when application server vendors have implemented the<br>
                                    Connector contracts.<br>
                                    2. To implement the Connector system contracts natively. This approach avoids the<br>
                                    overhead of wrapper classes, but the implementation effort may be more involved<br>
                                    and time-consuming. This alternative is a more long-term option.<br>
                                    Either approach will allow JDBC driver vendors to package their drivers as resource<br>
                                    adapters and get all the benefits of pluggability, packaging, and deployment.<br>
                                    Note – There are no plans to deprecate or remove the current JDBC interfaces,<br>
                                    DataSource, ConnectionPoolDataSource and XADataSource.<br>
                                    Chapter 19 Relationship to Connectors 169<br>
                                    19.3 Packaging JDBC Drivers in Connector<br>
                                    RAR File Format<br>
                                    Resource adapters can be packaged, along with a deployment descriptor, into a<br>
                                    Resource adapter ARchive, or RAR file. The RAR file contains the Java classes/<br>
                                    interfaces, native libraries, deployment descriptor, and other resources needed to<br>
                                    deploy the adapter.<br>
                                    The deployment descriptor maps the classes in the resource adapter to the specific<br>
                                    roles that they perform. The descriptor also details the capabilities of the resource<br>
                                    adapter in terms of what level of transactional support it provides, the kind of<br>
                                    security it supports, and so on.<br>
                                    CODE EXAMPLE 19-1 is an example of a deployment descriptor for a JDBC driver. The<br>
                                    class com.acme.JdbcManagedConnectionFactory could be supported by an<br>
                                    implementation of javax.sql.XADataSource. The resource adapter section<br>
                                    contains information on the level of transaction support, the mechanism used for<br>
                                    authentication, and configuration information for deploying the data source in the<br>
                                    JNDI namespace.<br>
                                    <?xml version="1.0" encoding="UTF-8"?><br>
                                    <!DOCTYPE connector PUBLIC ’-//Sun Microsystems, Inc.//DTD Connector 1.0//EN’<br>
                                    ’http://java.sun.com/j2ee/dtds/connector_1_0.dtd’><br>
                                    <connector><br>
                                        <display-name>Acme JDBC Adapter</display-name><br>
                                        <vendor-name>Acme Software Inc</vendor-name><br>
                                        <spec-version>1.0</spec-version><br>
                                        <version>1.0</version><br>
                                        <eis-type>JDBC Database</eis-type><br>
                                        <resourceadapter><br>
                                            <managedconnectionfactory-class>com.acme.JdbcManagedConnectionFactory</<br>
                                            managedconnectionfactory-class><br>
                                            <connectionfactory-interface>javax.sql.DataSource<connectionfactory-<br>
                                                interface><br>
                                                <connectionfactory-impl-class>com.acme.JdbcDataSource<connectionfactory-impl-<br>
                                                    class><br>
                                                    <connection-interface>java.sql.Connection</connection-interface><br>
                                                    <connection-impl-class>com.acme.JdbcConnection</connection-impl-class><br>
                                                    <transaction-support>xa_transaction</transaction-support><br>
                                                    <config-property><br>
                                                        <config-property-name>XADataSourceName</config-property-name><br>
                                                        <config-property-type>java.lang.String</config-property-type><br>
                                                        Chapter 19 Relationship to Connectors 170<br>
                                                        <config-property-value>jdbc/XAAcme</config-property-value><br>
                                                    </config-property><br>
                                                    <auth-mechanism><br>
                                                        <auth-mech-type>basic-password</auth-mech-type><br>
                                                        <credential-interface>javax.resource.security.PasswordCredential</<br>
                                                        credential-interface><br>
                                                    </auth-mechanism><br>
                                                    <reauthentication-support>false</reauthentication-support><br>
                                        </resourceadapter><br>
                                    </connector><br>
                                    CODE EXAMPLE 19-1 Example of a resource adapter deployment descriptor.<br>
                                    See the Connector specification for more details.<br>
                                    A-171<br>
                                    APPENDIX A<br>
                                    Revision History<br>
                                    Appendix TABLE A-1 presents a summary of the revisions made to this<br>
                                    specification.<br>
                                    TABLE A-1 Revision History<br>
                                    Revision Dash Date Comments<br>
                                    Expert Draft 01 June 2000 First expert draft<br>
                                    Expert Draft 02 July 2000 Second expert draft. Addressed<br>
                                    expert group comment and major<br>
                                    editorial updates.<br>
                                    Community<br>
                                    Draft<br>
                                    July 2000 First community draft. Minor<br>
                                    editiorial changes and clarifications<br>
                                    from Expert Draft 02.<br>
                                    A-172 JDBC 3.0 • October 2001<br>
                                    First Public<br>
                                    Draft<br>
                                    Sept 2000 Continuing editorial changes and<br>
                                    clarifications.<br>
                                    • updated section 6.2 to clarify<br>
                                    reference to SQL92. Made note that<br>
                                    SQL99 behaviour is to be used for<br>
                                    new features<br>
                                    • updated section 8.1 to allow for<br>
                                    SQL99 SQLStates to be returned.<br>
                                    Added new DatabaseMetaData<br>
                                    method to indicate if SQLStates<br>
                                    being returned are X/ Open or<br>
                                    SQL99<br>
                                    • updated section 14.2.2 to align<br>
                                    the ResultSet methods<br>
                                    relative and absolute with<br>
                                    SQL99 behaviour.<br>
                                    • updated section 14.1.3 making<br>
                                    the default holdability<br>
                                    implementation-defined and<br>
                                    adding new database metadata<br>
                                    method getResultSetHoldability to<br>
                                    report the default.<br>
                                    • updated section 13.6 removing<br>
                                    setGenerateKeys(boolean). Now<br>
                                    passing flag into execute/<br>
                                    executeUpdate/ prepareStatement.<br>
                                    • Added BOOLEAN data type.<br>
                                    Logically equivalent to BIT.<br>
                                    Updated data type table to reflect<br>
                                    new type.<br>
                                    TABLE A-1 Revision History<br>
                                    Revision Dash Date Comments<br>
                                    Appendix A Revision History A-173<br>
                                    Proposed Final<br>
                                    Draft<br>
                                    1 Oct 2000 Continued minor editorial changes<br>
                                    and clarification.<br>
                                    • added getJDBCMajorVersion<br>
                                    and getJDBCMinorVersion to<br>
                                    the DatabaseMetaData interface.<br>
                                    • updated section 6.5 adding new<br>
                                    DatabaseMetaData methods<br>
                                    • updated section 6.7 adding<br>
                                    missing constructor<br>
                                    java.sql.Time(int, int,<br>
                                    int) to the list of deprecated<br>
                                    methods<br>
                                    • further updated SQL syntax<br>
                                    used in Chapters 16 & 17.<br>
                                    • renamed the methods getValue<br>
                                    and setValue in the Ref interface<br>
                                    to getObject and setObject<br>
                                    respectively.<br>
                                    • added new example to section<br>
                                    13.6 to clarify process of retrieving<br>
                                    named columns.<br>
                                    • Added new section 9.3.1 on<br>
                                    SQLPermission.<br>
                                    • Added missing methods to<br>
                                    register parameters and retrieve<br>
                                    parameters by name.<br>
                                    Proposed Final<br>
                                    Draft<br>
                                    2 Jan 2001 Minor editorial changes and<br>
                                    clarification.<br>
                                    • fixed errors in Chapter 5, some<br>
                                    classes/ interfaces were<br>
                                    misclassified.<br>
                                    • added new sections 9.2.1 and<br>
                                    9.2.2 on URL syntax and<br>
                                    subprotocol registration.<br>
                                    • added new wording 16.5.5<br>
                                    allowing user-defined references to<br>
                                    be retrieved and set using the<br>
                                    appropriate getter and setter<br>
                                    methods.<br>
                                    Proposed Final<br>
                                    Draft<br>
                                    3 April 2001 Removed method<br>
                                    PooledConnection.CloseAll().<br>
                                    Changes to the javax.sql interfaces<br>
                                    in this release break J2EE<br>
                                    compatility rules.<br>
                                    TABLE A-1 Revision History<br>
                                    Revision Dash Date Comments<br>
                                    A-174 JDBC 3.0 • October 2001<br>
                                    Proposed Final<br>
                                    Draft<br>
                                    4 October 2001 • clarified how updates affect<br>
                                    LOBs. Added new method<br>
                                    locatorsUpdateCopy to<br>
                                    DatabaseMetaData interface.<br>
                                    • noted further limitations of XA<br>
                                    and transactional properties<br>
                                    • removed checked exception<br>
                                    MalformedURLException from<br>
                                    interface definition of getURL<br>
                                    methods in the ResultSet,<br>
                                    CallableStatement, SQLInput<br>
                                    interfaces<br>
                                    • updated JavaDoc to reflect the<br>
                                    definition of the ResultSet method<br>
                                    relative<br>
                                    TABLE A-1 Revision History<br>
                                    Revision Dash Date Comments<br>
                                    B-175<br>
                                    APPENDIX B<br>
                                    Data Type Conversion Tables<br>
                                    The tables provided here describe the various mappings and conversions that<br>
                                    drivers must support.<br>
                                    TABLE B-1 JDBC Types Mapped to Java Types<br>
                                    This table shows the conceptual correspondence between JDBC types and Java<br>
                                    types. A programmer should write code with this mapping in mind. For example, if<br>
                                    a value in the database is a SMALLINT, a short should be the data type used in a<br>
                                    JDBC application.<br>
                                    All CallableStatement getter methods except for getObject use this mapping.<br>
                                    The getObject methods for both the CallableStatement and ResultSet<br>
                                    interfaces use the mapping in TABLE B-3 .<br>
                                    TABLE B-2 Java Types Mapped to JDBC Types<br>
                                    This table shows the mapping a driver should use for the updater methods in the<br>
                                    ResultSet interface and for IN parameters. PreparedStatement setter methods,<br>
                                    RowSet setter methods and SQLOutput writer methods use this table for mapping<br>
                                    an IN parameter, which is a Java type, to the JDBC type that will be sent to the<br>
                                    database. Note that the setObject methods for PreparedStatement and<br>
                                    Rowset use the mapping shown in TABLE B-4 .<br>
                                    TABLE B-3 JDBC Types Mapped to Java Object Types<br>
                                    ResultSet.getObject and CallableStatement.getObject use the mapping<br>
                                    shown in this table for standard mappings.<br>
                                    TABLE B-4 Java Object Types Mapped to JDBC Types<br>
                                    PreparedStatement.setObject and RowSet.setObject use the mapping<br>
                                    shown in this table when no parameter specifying a target JDBC type is provided.<br>
                                    TABLE B-5 Conversions by setObject from Java Obejct Types to JDBC Types<br>
                                    This table shows which JDBC types may be specified as the target JDBC type to the<br>
                                    methods PreparedStatement.setObject and RowSet.setObject.<br>
                                    B-176 JDBC 3.0 • October 2001<br>
                                    In addition, for user-generated REF types and for DISTINCT types, the setter<br>
                                    methods that are appropriate for the representation type of the REF type or for the<br>
                                    source type of the DISTINCT type can be used.<br>
                                    TABLE B-6 Type Conversions Supported by ResultSet getter Methods<br>
                                    This table shows which JDBC types may be returned by ResultSet getter methods.<br>
                                    A bold X indicates the method recommended for retrieving a JDBC type. A plain x<br>
                                    indicates for which JDBC types it is possible to use a getter method.<br>
                                    This table also shows the conversions used by the SQLInput reader methods, except<br>
                                    that they use only the recommended conversions. For user generated REF types, the<br>
                                    reader methods that are appropriate for the representation type of the REF type may<br>
                                    be used.<br>
                                    Appendix B Data Type Conversion Tables B-177<br>
                                    JDBC Type Java Type<br>
                                    CHAR String<br>
                                    VARCHAR String<br>
                                    LONGVARCHAR String<br>
                                    NUMERIC java.math.BigDecimal<br>
                                    DECIMAL java.math.BigDecimal<br>
                                    BIT boolean<br>
                                    BOOLEAN boolean<br>
                                    TINYINT byte<br>
                                    SMALLINT short<br>
                                    INTEGER int<br>
                                    BIGINT long<br>
                                    REAL float<br>
                                    FLOAT double<br>
                                    DOUBLE double<br>
                                    BINARY byte[]<br>
                                    VARBINARY byte[]<br>
                                    LONGVARBINARY byte[]<br>
                                    DATE java.sql.Date<br>
                                    TIME java.sql.Time<br>
                                    TIMESTAMP java.sql.Timestamp<br>
                                    CLOB Clob<br>
                                    BLOB Blob<br>
                                    ARRAY Array<br>
                                    DISTINCT mapping of underlying type<br>
                                    STRUCT Struct<br>
                                    REF Ref<br>
                                    DATALINK java.net.URL<br>
                                    JAVA_OBJECT underlying Java class<br>
                                    TABLE B-1 JDBC Types Mapped to Java Types<br>
                                    B-178 JDBC 3.0 • October 2001<br>
                                    Java Type JDBC Type<br>
                                    String CHAR , VARCHAR , or LONGVARCHAR<br>
                                    java.math.BigDecimal NUMERIC<br>
                                    boolean BIT or BOOLEAN<br>
                                    byte TINYINT<br>
                                    short SMALLINT<br>
                                    int INTEGER<br>
                                    long BIGINT<br>
                                    float REAL<br>
                                    double DOUBLE<br>
                                    byte[] BINARY , VARBINARY , or<br>
                                    LONGVARBINARY<br>
                                    java.sql.Date DATE<br>
                                    java.sql.Time TIME<br>
                                    java.sql.Timestamp TIMESTAMP<br>
                                    Clob CLOB<br>
                                    Blob BLOB<br>
                                    Array ARRAY<br>
                                    Struct STRUCT<br>
                                    Ref REF<br>
                                    java.net.URL DATALINK<br>
                                    Java class JAVA_OBJECT<br>
                                    TABLE B-2 Standard Mapping from Java Types to JDBC Types<br>
                                    Appendix B Data Type Conversion Tables B-179<br>
                                    JDBC Type Java Object Type<br>
                                    CHAR String<br>
                                    VARCHAR String<br>
                                    LONGVARCHAR String<br>
                                    NUMERIC java.math.BigDecimal<br>
                                    DECIMAL java.math.BigDecimal<br>
                                    BIT Boolean<br>
                                    BOOLEAN Boolean<br>
                                    TINYINT Integer<br>
                                    SMALLINT Integer<br>
                                    INTEGER Integer<br>
                                    BIGINT Long<br>
                                    REAL Float<br>
                                    FLOAT Double<br>
                                    DOUBLE Double<br>
                                    BINARY byte[]<br>
                                    VARBINARY byte[]<br>
                                    LONGVARBINARY byte[]<br>
                                    DATE java.sql.Date<br>
                                    TIME java.sql.Time<br>
                                    TIMESTAMP java.sql.Timestamp<br>
                                    DISTINCT Object type of underlying type<br>
                                    CLOB Clob<br>
                                    BLOB Blob<br>
                                    ARRAY Array<br>
                                    STRUCT Struct or SQLData<br>
                                    REF Ref<br>
                                    DATALINK java.net.URL<br>
                                    JAVA_OBJECT underlying Java class<br>
                                    TABLE B-3 Mapping from JDBC Types to Java Object Types<br>
                                    B-180 JDBC 3.0 • October 2001<br>
                                    Java Object Type JDBC Type<br>
                                    String CHAR , VARCHAR , or LONGVARCHAR<br>
                                    java.math.BigDecimal NUMERIC<br>
                                    Boolean BIT or BOOLEAN<br>
                                    Integer INTEGER<br>
                                    Long BIGINT<br>
                                    Float REAL<br>
                                    Double DOUBLE<br>
                                    byte[] BINARY , VARBINARY , or<br>
                                    LONGVARBINARY<br>
                                    java.sql.Date DATE<br>
                                    java.sql.Time TIME<br>
                                    java.sql.Timestamp TIMESTAMP<br>
                                    Clob CLOB<br>
                                    Blob BLOB<br>
                                    Array ARRAY<br>
                                    Struct STRUCT<br>
                                    Ref REF<br>
                                    java.net.URL DATALINK<br>
                                    Java class JAVA_OBJECT<br>
                                    TABLE B-4 Mapping from Java Object Types to JDBC Types<br>
                                    Appendix B Data Type Conversion Tables B-181<br>
                                    TINYINT<br>
                                    SMALLINT<br>
                                    INTEGER<br>
                                    BIGINT<br>
                                    REAL<br>
                                    FLOAT<br>
                                    DOUBLE<br>
                                    DECIMAL<br>
                                    NUMERIC<br>
                                    BIT<br>
                                    BOOLEAN<br>
                                    CHAR<br>
                                    VARCHAR<br>
                                    LONGVARCHAR<br>
                                    BINARY<br>
                                    VARBINARY<br>
                                    LONGVARBINARY<br>
                                    DATE<br>
                                    TIME<br>
                                    TIMESTAMP<br>
                                    ARRAY<br>
                                    BLOB<br>
                                    CLOB<br>
                                    STRUCT<br>
                                    REF<br>
                                    DATALINK<br>
                                    JAVA_OBJECT<br>
                                    String<br>
                                    x x x x x x x x x x x x x x x x x x x x<br>
                                    java.math.<br>
                                    BigDecimal<br>
                                    x x x x x x x x x x x x x x<br>
                                    Boolean<br>
                                    x x x x x x x x x x x x x x<br>
                                    Integer<br>
                                    x x x x x x x x x x x x x x<br>
                                    Long<br>
                                    x x x x x x x x x x x x x x<br>
                                    Float<br>
                                    x x x x x x x x x x x x x x<br>
                                    Double<br>
                                    x x x x x x x x x x x x x x<br>
                                    byte[]<br>
                                    x x x<br>
                                    java.sql.<br>
                                    Date<br>
                                    x x x x x<br>
                                    java.sql.<br>
                                    Time<br>
                                    x x x x<br>
                                    java.sql.<br>
                                    Timestamp<br>
                                    x x x x x x<br>
                                    Array<br>
                                    x<br>
                                    Blob<br>
                                    x<br>
                                    Clob<br>
                                    x<br>
                                    Struct<br>
                                    x<br>
                                    Ref<br>
                                    x<br>
                                    java.net.URL<br>
                                    x<br>
                                    Java class<br>
                                    x<br>
                                    TABLE B-5 Conversions Performed by setObject Between Java Object Types<br>
                                    and Target JDBC Types<br>
                                    B-182 JDBC 3.0 • October 2001<br>
                                    TINYINT<br>
                                    SMALLINT<br>
                                    INTEGER<br>
                                    BIGINT<br>
                                    REAL<br>
                                    FLOAT<br>
                                    DOUBLE<br>
                                    DECIMAL<br>
                                    NUMERIC<br>
                                    BIT<br>
                                    BOOLEAN<br>
                                    CHAR<br>
                                    VARCHAR<br>
                                    LONGVARCHAR<br>
                                    BINARY<br>
                                    VARBINARY<br>
                                    LONGVARBINARY<br>
                                    DATE<br>
                                    TIME<br>
                                    TIMESTAMP<br>
                                    CLOB<br>
                                    BLOB<br>
                                    ARRAY<br>
                                    REF<br>
                                    DATALINK<br>
                                    STRUCT<br>
                                    JAVA_OBJECT<br>
                                    getByte<br>
                                    X x x x x x x x x x x x x x<br>
                                    getShort<br>
                                    x X x x x x x x x x x x x x<br>
                                    getInt<br>
                                    x x X x x x x x x x x x x x<br>
                                    getLong<br>
                                    x x x X x x x x x x x x x x<br>
                                    getFloat<br>
                                    x x x x X x x x x x x x x x<br>
                                    getDouble<br>
                                    x x x x x X X x x x x x x x<br>
                                    getBigDecimal<br>
                                    x x x x x x x X X x x x x x<br>
                                    getBoolean<br>
                                    x x x x x x x x x X X x x x<br>
                                    getString<br>
                                    x x x x x x x x x x x X X x x x x x x x x<br>
                                    getBytes<br>
                                    X X x<br>
                                    getDate<br>
                                    x x x X x<br>
                                    getTime<br>
                                    x x x X x<br>
                                    getTimestamp<br>
                                    x x x x x X<br>
                                    getAsciiStream<br>
                                    x x X x x x<br>
                                    getBinaryStream<br>
                                    x x X<br>
                                    getCharacterStream<br>
                                    x x X x x x<br>
                                    getClob<br>
                                    X<br>
                                    getBlob<br>
                                    X<br>
                                    getArray<br>
                                    X<br>
                                    getRef<br>
                                    X<br>
                                    getURL<br>
                                    X<br>
                                    getObject<br>
                                    x x x x x x x x x x x x x x x x x x x x x x x x X X<br>
                                    TABLE B-6 Use of ResultSet getter Methods to Retrieve JDBC Data Types<br>
                                    C-183<br>
                                    APPENDIX C<br>
                                    Scalar Functions<br>
                                    The JDBC API supports escape syntax for numeric, string, time, date, system, and<br>
                                    conversion functions on scalar values. These scalar functions may be used in SQL<br>
                                    strings as described in Section 13.4.1 “Scalar Functions” on page 13-109. The Open<br>
                                    Group CLI specification provides more information on the semantics of the scalar<br>
                                    functions. The scalar functions are listed below for reference.<br>
                                    If a DBMS supports a scalar function, the driver should also. Because scalar<br>
                                    functions are supported by different DBMSs with slightly different syntax, it is the<br>
                                    driver’s job either to map them into the appropriate syntax or to implement the<br>
                                    functions directly in the driver.<br>
                                    A user should be able to find out which functions are supported by calling metadata<br>
                                    methods. For example, the method DatabaseMetaData.getNumericFunctions<br>
                                    returns a comma separated list of the Open Group CLI names of the numeric<br>
                                    functions supported. Similarly, the method<br>
                                    DatabaseMetaData.getStringFunctions returns a list of string functions<br>
                                    supported, and so on.<br>
                                    The scalar functions are listed by category:<br>
                                    C.1 Numeric Functions<br>
                                    Function Name Function Returns<br>
                                    ABS(number) Absolute value of number<br>
                                    ACOS(float) Arccosine, in radians, of float<br>
                                    ASIN(float) Arcsine, in radians, of float<br>
                                    ATAN(float) Arctangent, in radians, of float<br>
                                    ATAN2(float1, float2) Arctangent, in radians, of float2 / float1<br>
                                    CEILING(number) Smallest integer >= number<br>
                                    COS(float) Cosine of float radians<br>
                                    COT(float) Cotangent of float radians<br>
                                    DEGREES(number) Degrees in number radians<br>
                                    C-184 JDBC 3.0 • October 2001<br>
                                    EXP(float) Exponential function of float<br>
                                    FLOOR(number) Largest integer <= number<br>
                                    LOG(float) Base e logarithm of float<br>
                                    LOG10(float) Base 10 logarithm of float<br>
                                    MOD(integer1, integer2) Remainder for integer1 / integer2<br>
                                    PI() The constant pi<br>
                                    POWER(number, power) number raised to (integer) power<br>
                                    RADIANS(number) Radians in number degrees<br>
                                    RAND(integer) Random floating point for seed integer<br>
                                    ROUND(number, places) number rounded to places places<br>
                                    SIGN(number) -1 to indicate number is < 0;<br>
                                    0 to indicate number is = 0;<br>
                                    1 to indicate number is > 0<br>
                                    SIN(float) Sine of float radians<br>
                                    SQRT(float) Square root of float<br>
                                    TAN(float) Tangent of float radians<br>
                                    TRUNCATE(number, places) number truncated to places places<br>
                                    C.2 String Functions<br>
                                    Function Name Function Returns<br>
                                    ASCII(string) Integer representing the ASCIIcode value ofthe leftmost character in string<br>
                                    CHAR(code) Character with ASCII code value code, where code is between 0 and 255<br>
                                    CONCAT(string1, string2) Character string formed by appending string2 to string1; if a string is<br>
                                    null, the result is DBMS-dependent<br>
                                    DIFFERENCE(string1, Integer indicating the difference between the<br>
                                    string2) values returned by the function SOUNDEX for
</body>
</html>